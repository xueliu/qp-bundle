<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: qf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id="logo" title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com"></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QP/C
   &#160;<span id="projectnumber">6.8.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('qf_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qf.h File Reference<div class="ingroups"><a class="el" href="group__qf.html">QF</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>QF/C platform-independent public interface.
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="qpset_8h_source.html">qpset.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for qf.h:</div>
<div class="dyncontent">
<div class="center"><img src="qf_8h__incl.png" border="0" usemap="#qf_8h" alt=""/></div>
<map name="qf_8h" id="qf_8h">
<area shape="rect" title="QF/C platform&#45;independent public interface." alt="" coords="17,5,59,32"/>
<area shape="rect" href="qpset_8h.html" title="QP native, platform&#45;independent priority sets of 32 or 64 elements." alt="" coords="5,80,71,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="qf_8h__dep__incl.png" border="0" usemap="#qf_8hdep" alt=""/></div>
<map name="qf_8hdep" id="qf_8hdep">
<area shape="rect" title="QF/C platform&#45;independent public interface." alt="" coords="525,5,567,32"/>
<area shape="rect" href="qk_2qf__port_8h.html" title="QF/C port example for QK, generic C compiler." alt="" coords="414,80,486,107"/>
<area shape="rect" href="qv_2qf__port_8h.html" title="QF/C port example for QV, generic C compiler." alt="" coords="510,80,582,107"/>
<area shape="rect" href="qxk_2qf__port_8h.html" title="QF/C port example for QXK, generic C compiler." alt="" coords="606,80,678,107"/>
<area shape="rect" href="qpc_8h.html" title="QP/C public interface including backwards&#45;compatibility layer." alt="" coords="5,229,60,256"/>
<area shape="rect" href="qf__act_8c.html" title="QActive services and ::QF support code" alt="" coords="84,229,152,256"/>
<area shape="rect" href="qf__actq_8c.html" title="QActive native queue operations (based on QEQueue)" alt="" coords="177,229,251,256"/>
<area shape="rect" href="qf__defer_8c.html" title="QActive_defer() and QActive_recall() implementation." alt="" coords="276,229,355,256"/>
<area shape="rect" href="qf__dyn_8c.html" title="QF/C dynamic event management." alt="" coords="379,229,449,256"/>
<area shape="rect" href="qf__mem_8c.html" title="QMPool implementatin (Memory Pool)" alt="" coords="473,229,552,256"/>
<area shape="rect" href="qf__ps_8c.html" title="Publish&#45;Subscribe services." alt="" coords="577,229,641,256"/>
<area shape="rect" href="qf__qact_8c.html" title="QActive_ctor() definition." alt="" coords="933,155,1007,181"/>
<area shape="rect" href="qf__qeq_8c.html" title="QEQueue implementation (QP native thread&#45;safe queue)" alt="" coords="665,229,736,256"/>
<area shape="rect" href="qf__qmact_8c.html" title="QMActive_ctor() definition." alt="" coords="1032,155,1119,181"/>
<area shape="rect" href="qf__time_8c.html" title="QTimeEvt implementation and QF system clock tick QF_tickX_())" alt="" coords="1343,229,1418,256"/>
<area shape="rect" href="qutest_8c.html" title="QF/C stub for QUTEST unit testing." alt="" coords="1442,229,1511,256"/>
<area shape="rect" href="qv_8c.html" title="Cooperative QV kernel, definition of QP::QV_readySet_ and implementation of kernel&#45;specific functions..." alt="" coords="1535,229,1581,256"/>
<area shape="rect" href="qs__port_8h.html" title="QS/C port to a 32&#45;bit CPU and a generic C compiler." alt="" coords="1143,155,1219,181"/>
<area shape="rect" href="qxk_2qs__port_8h.html" title="QS/C port to a 32&#45;bit CPU and a generic C compiler." alt="" coords="680,155,756,181"/>
<area shape="rect" href="qep__hsm_8c.html" title="QHsm implementation" alt="" coords="1045,229,1132,256"/>
<area shape="rect" href="qep__msm_8c.html" title="QMsm implementation" alt="" coords="1157,229,1247,256"/>
<area shape="rect" href="qs_8c.html" title="QS software tracing services." alt="" coords="1272,229,1319,256"/>
<area shape="rect" href="qs__64bit_8c.html" title="QS long&#45;long (64&#45;bit) output." alt="" coords="761,229,843,256"/>
<area shape="rect" href="qs__fp_8c.html" title="QS floating point output implementation." alt="" coords="867,229,931,256"/>
<area shape="rect" href="qs__rx_8c.html" title="QS/C receive channel services." alt="" coords="956,229,1021,256"/>
</map>
</div>
</div>
<p><a href="qf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:struct_q_active"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#struct_q_active">QActive</a></td></tr>
<tr class="memdesc:struct_q_active"><td class="mdescLeft">&#160;</td><td class="mdescRight">Active Object (based on <a class="el" href="qep_8h.html#struct_q_hsm">QHsm</a> implementation)  <a href="qf_8h.html#struct_q_active">More...</a><br /></td></tr>
<tr class="separator:struct_q_active"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_active_vtable.html">QActiveVtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual table for the <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a> class.  <a href="struct_q_active_vtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_q_time_evt"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a></td></tr>
<tr class="memdesc:struct_q_time_evt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time Event structure.  <a href="qf_8h.html#struct_q_time_evt">More...</a><br /></td></tr>
<tr class="separator:struct_q_time_evt"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3123ef03f5d66d866da12c736ac574b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a3123ef03f5d66d866da12c736ac574b0">QACTIVE_START</a>(me_,  prio_,  qSto_,  qLen_,  stkSto_,  stkLen_,  par_)</td></tr>
<tr class="memdesc:a3123ef03f5d66d866da12c736ac574b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphically start an active object.  <a href="qf_8h.html#a3123ef03f5d66d866da12c736ac574b0">More...</a><br /></td></tr>
<tr class="separator:a3123ef03f5d66d866da12c736ac574b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c56990d949c8708e3fe2b737f2e65c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c">QACTIVE_POST</a>(me_,  e_,  sender_)</td></tr>
<tr class="memdesc:ab7c56990d949c8708e3fe2b737f2e65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphically posts an event to an active object (FIFO) with delivery guarantee.  <a href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c">More...</a><br /></td></tr>
<tr class="separator:ab7c56990d949c8708e3fe2b737f2e65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766856b24aa5163b7ca90bc3432f1e3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a766856b24aa5163b7ca90bc3432f1e3e">QACTIVE_POST_X</a>(me_,  e_,  margin_,  sender_)</td></tr>
<tr class="memdesc:a766856b24aa5163b7ca90bc3432f1e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphically posts an event to an active object (FIFO) without delivery guarantee.  <a href="qf_8h.html#a766856b24aa5163b7ca90bc3432f1e3e">More...</a><br /></td></tr>
<tr class="separator:a766856b24aa5163b7ca90bc3432f1e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f94b69fa7148180c19d501ce2ee7032"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a2f94b69fa7148180c19d501ce2ee7032">QACTIVE_POST_LIFO</a>(me_,  e_)&#160;&#160;&#160;((*((<a class="el" href="struct_q_active_vtable.html">QActiveVtable</a> const *)((me_)-&gt;super.vptr))-&gt;postLIFO)((me_), (e_)))</td></tr>
<tr class="memdesc:a2f94b69fa7148180c19d501ce2ee7032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphically posts an event to an active object using the Last-In-First-Out (LIFO) policy.  <a href="qf_8h.html#a2f94b69fa7148180c19d501ce2ee7032">More...</a><br /></td></tr>
<tr class="separator:a2f94b69fa7148180c19d501ce2ee7032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd57334f2a1664a168b0702a106e0782"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782">QF_PUBLISH</a>(e_,  sender_)&#160;&#160;&#160;(<a class="el" href="qf__ps_8c.html#a1fb533f5e56964494448184a1991f8db">QF_publish_</a>((e_), (void const *)(sender_)))</td></tr>
<tr class="memdesc:afd57334f2a1664a168b0702a106e0782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the event publishing facility <a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>.  <a href="qf_8h.html#afd57334f2a1664a168b0702a106e0782">More...</a><br /></td></tr>
<tr class="separator:afd57334f2a1664a168b0702a106e0782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1970e16f4d010b5e5b2fd046aac41e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(tickRate_,  sender_)&#160;&#160;&#160;(<a class="el" href="qf__time_8c.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82">QF_tickX_</a>((tickRate_), (sender_)))</td></tr>
<tr class="memdesc:a1f1970e16f4d010b5e5b2fd046aac41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the system clock tick processing <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a>.  <a href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">More...</a><br /></td></tr>
<tr class="separator:a1f1970e16f4d010b5e5b2fd046aac41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1957439cb1ecff92be7b7401bf3159"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a>&#160;&#160;&#160;((<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)0xFFFFU)</td></tr>
<tr class="memdesc:a3c1957439cb1ecff92be7b7401bf3159"><td class="mdescLeft">&#160;</td><td class="mdescRight">special value of margin that causes asserting failure in case event allocation or event posting fails  <a href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">More...</a><br /></td></tr>
<tr class="separator:a3c1957439cb1ecff92be7b7401bf3159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095356f76aa32cb738325abfa55e96fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a095356f76aa32cb738325abfa55e96fc">QF_TICK</a>(sender_)&#160;&#160;&#160;<a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(0U, (sender_))</td></tr>
<tr class="memdesc:a095356f76aa32cb738325abfa55e96fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the system clock tick processing for rate 0.  <a href="qf_8h.html#a095356f76aa32cb738325abfa55e96fc">More...</a><br /></td></tr>
<tr class="separator:a095356f76aa32cb738325abfa55e96fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd823f3a9e8b3206a3460a108d5fa3e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a>(evtT_,  sig_)</td></tr>
<tr class="memdesc:abd823f3a9e8b3206a3460a108d5fa3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a dynamic event.  <a href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">More...</a><br /></td></tr>
<tr class="separator:abd823f3a9e8b3206a3460a108d5fa3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52b4d3c43a262022392c6e11be06436"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a>(e_,  evtT_,  margin_,  sig_)</td></tr>
<tr class="memdesc:aa52b4d3c43a262022392c6e11be06436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a dynamic event (non-asserting version).  <a href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">More...</a><br /></td></tr>
<tr class="separator:aa52b4d3c43a262022392c6e11be06436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0">Q_NEW_REF</a>(evtRef_,  evtT_)&#160;&#160;&#160;((evtRef_) = (evtT_ const *)<a class="el" href="qf__dyn_8c.html#a770a14292ba710e2843901dca56cb4bb">QF_newRef_</a>(e, (evtRef_)))</td></tr>
<tr class="memdesc:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new reference of the current event <code>e</code>  <a href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0">More...</a><br /></td></tr>
<tr class="separator:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed009a86c52cf2b8d811389fabb5f23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23">Q_DELETE_REF</a>(evtRef_)</td></tr>
<tr class="memdesc:aaed009a86c52cf2b8d811389fabb5f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the event reference.  <a href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23">More...</a><br /></td></tr>
<tr class="separator:aaed009a86c52cf2b8d811389fabb5f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2">QF_CRIT_EXIT_NOP</a>()&#160;&#160;&#160;((void)0)</td></tr>
<tr class="memdesc:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-operation for exiting a critical section.  <a href="qf_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2">More...</a><br /></td></tr>
<tr class="separator:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abbb0c00f8a289282390cbd0173eee21c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#abbb0c00f8a289282390cbd0173eee21c">QEvtSize</a></td></tr>
<tr class="separator:abbb0c00f8a289282390cbd0173eee21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6eee6e3b8577f256e4c8de9619e19c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="qf_8h.html#struct_q_active">QActive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c">QMActive</a></td></tr>
<tr class="memdesc:acb6eee6e3b8577f256e4c8de9619e19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">QMActive active object (based on <a class="el" href="qep_8h.html#ad55e90747946de1e62e356ea04f5eaaf" title="QM State Machine implementation strategy.">QMsm</a> implementation)  <a href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c">More...</a><br /></td></tr>
<tr class="separator:acb6eee6e3b8577f256e4c8de9619e19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ae90801798660dc4c3aea59bfcbba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_q_active_vtable.html">QActiveVtable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a001ae90801798660dc4c3aea59bfcbba">QMActiveVtable</a></td></tr>
<tr class="memdesc:a001ae90801798660dc4c3aea59bfcbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Table for the <a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> class (inherited from <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>.  <a href="qf_8h.html#a001ae90801798660dc4c3aea59bfcbba">More...</a><br /></td></tr>
<tr class="separator:a001ae90801798660dc4c3aea59bfcbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3526b0c899ab9687db250ab58551e0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a></td></tr>
<tr class="separator:a1f3526b0c899ab9687db250ab58551e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1532f57deb6a85353b9c04bf054fec77"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="qpset_8h.html#struct_q_p_set">QPSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">QSubscrList</a></td></tr>
<tr class="memdesc:a1532f57deb6a85353b9c04bf054fec77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscriber-List structure.  <a href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">More...</a><br /></td></tr>
<tr class="separator:a1532f57deb6a85353b9c04bf054fec77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83956ec689cb4ccf4732a91c7821894"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="qf_8h.html#struct_q_active">QActive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ad83956ec689cb4ccf4732a91c7821894">QTicker</a></td></tr>
<tr class="memdesc:ad83956ec689cb4ccf4732a91c7821894"><td class="mdescLeft">&#160;</td><td class="mdescRight">QTicker Active Object class.  <a href="qf_8h.html#ad83956ec689cb4ccf4732a91c7821894">More...</a><br /></td></tr>
<tr class="separator:ad83956ec689cb4ccf4732a91c7821894"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13edf5eeb78176195720ac88bf70b3ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a13edf5eeb78176195720ac88bf70b3ef">QActive_ctor</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const me, <a class="el" href="qep_8h.html#a797a6e3e20119fcb0911cffb94e49543">QStateHandler</a> initial)</td></tr>
<tr class="memdesc:a13edf5eeb78176195720ac88bf70b3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">protected "constructor" of an <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a> active object  <a href="qf_8h.html#a13edf5eeb78176195720ac88bf70b3ef">More...</a><br /></td></tr>
<tr class="separator:a13edf5eeb78176195720ac88bf70b3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2510a52f1185e2561fa78323983c04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ae2510a52f1185e2561fa78323983c04d">QActive_subscribe</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const me, <a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const sig)</td></tr>
<tr class="memdesc:ae2510a52f1185e2561fa78323983c04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes for delivery of signal <code>sig</code> to the active object <code>me</code>.  <a href="qf_8h.html#ae2510a52f1185e2561fa78323983c04d">More...</a><br /></td></tr>
<tr class="separator:ae2510a52f1185e2561fa78323983c04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf08b1345a60cb4cd2d580f448f819d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a0cf08b1345a60cb4cd2d580f448f819d">QActive_unsubscribe</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const me, <a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const sig)</td></tr>
<tr class="memdesc:a0cf08b1345a60cb4cd2d580f448f819d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-subscribes from the delivery of signal <code>sig</code> to the AO <code>me</code>.  <a href="qf_8h.html#a0cf08b1345a60cb4cd2d580f448f819d">More...</a><br /></td></tr>
<tr class="separator:a0cf08b1345a60cb4cd2d580f448f819d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec64ea18ec1909aa5ce20ca1c154bea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aec64ea18ec1909aa5ce20ca1c154bea4">QActive_unsubscribeAll</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const me)</td></tr>
<tr class="memdesc:aec64ea18ec1909aa5ce20ca1c154bea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-subscribes from the delivery of all signals to the AO <code>me</code>.  <a href="qf_8h.html#aec64ea18ec1909aa5ce20ca1c154bea4">More...</a><br /></td></tr>
<tr class="separator:aec64ea18ec1909aa5ce20ca1c154bea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57469f44aa23b185fbe4688f35a1a090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a57469f44aa23b185fbe4688f35a1a090">QActive_defer</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const me, <a class="el" href="qequeue_8h.html#struct_q_e_queue">QEQueue</a> *const eq, <a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> const *const e)</td></tr>
<tr class="memdesc:a57469f44aa23b185fbe4688f35a1a090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defer an event <code>e</code> to a given event queue <code>eq</code>.  <a href="qf_8h.html#a57469f44aa23b185fbe4688f35a1a090">More...</a><br /></td></tr>
<tr class="separator:a57469f44aa23b185fbe4688f35a1a090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2036d245c002aae06a8a0bb28799d45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a2036d245c002aae06a8a0bb28799d45f">QActive_recall</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const me, <a class="el" href="qequeue_8h.html#struct_q_e_queue">QEQueue</a> *const eq)</td></tr>
<tr class="memdesc:a2036d245c002aae06a8a0bb28799d45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a deferred event from a given event queue <code>eq</code>.  <a href="qf_8h.html#a2036d245c002aae06a8a0bb28799d45f">More...</a><br /></td></tr>
<tr class="separator:a2036d245c002aae06a8a0bb28799d45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad408065e3bbdde9ed07403432a5ba5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ad408065e3bbdde9ed07403432a5ba5c4">QActive_flushDeferred</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const me, <a class="el" href="qequeue_8h.html#struct_q_e_queue">QEQueue</a> *const eq)</td></tr>
<tr class="memdesc:ad408065e3bbdde9ed07403432a5ba5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the specified deferred queue <code>eq</code>.  <a href="qf_8h.html#ad408065e3bbdde9ed07403432a5ba5c4">More...</a><br /></td></tr>
<tr class="separator:ad408065e3bbdde9ed07403432a5ba5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbac2dae55570a9bca8a4d6f1f72bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a4cbac2dae55570a9bca8a4d6f1f72bd1">QActive_setAttr</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const me, <a class="el" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> attr1, void const *attr2)</td></tr>
<tr class="memdesc:a4cbac2dae55570a9bca8a4d6f1f72bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic setting of additional attributes (useful in QP ports)  <a href="qf_8h.html#a4cbac2dae55570a9bca8a4d6f1f72bd1">More...</a><br /></td></tr>
<tr class="separator:a4cbac2dae55570a9bca8a4d6f1f72bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11417cfd658a571c1b21a47e261b58be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a11417cfd658a571c1b21a47e261b58be">QMActive_ctor</a> (<a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c">QMActive</a> *const me, <a class="el" href="qep_8h.html#a797a6e3e20119fcb0911cffb94e49543">QStateHandler</a> initial)</td></tr>
<tr class="memdesc:a11417cfd658a571c1b21a47e261b58be"><td class="mdescLeft">&#160;</td><td class="mdescRight">protected "constructor" of an <a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> active object.  <a href="qf_8h.html#a11417cfd658a571c1b21a47e261b58be">More...</a><br /></td></tr>
<tr class="separator:a11417cfd658a571c1b21a47e261b58be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790b654800908426f563112107b11647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a790b654800908426f563112107b11647">QTimeEvt_ctorX</a> (<a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const me, <a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const act, <a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const sig, <a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> tickRate)</td></tr>
<tr class="memdesc:a790b654800908426f563112107b11647"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extended "constructor" to initialize a Time Event.  <a href="qf_8h.html#a790b654800908426f563112107b11647">More...</a><br /></td></tr>
<tr class="separator:a790b654800908426f563112107b11647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbcb00315fb8bb8641003b2b2d07ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a9bbcb00315fb8bb8641003b2b2d07ce4">QTimeEvt_armX</a> (<a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const me, <a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a> const nTicks, <a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a> const interval)</td></tr>
<tr class="memdesc:a9bbcb00315fb8bb8641003b2b2d07ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arm a time event (one shot or periodic) for direct event posting.  <a href="qf_8h.html#a9bbcb00315fb8bb8641003b2b2d07ce4">More...</a><br /></td></tr>
<tr class="separator:a9bbcb00315fb8bb8641003b2b2d07ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5734e32caac22b89766a4b90a1679b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a3a5734e32caac22b89766a4b90a1679b">QTimeEvt_rearm</a> (<a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const me, <a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a> const nTicks)</td></tr>
<tr class="memdesc:a3a5734e32caac22b89766a4b90a1679b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearm a time event.  <a href="qf_8h.html#a3a5734e32caac22b89766a4b90a1679b">More...</a><br /></td></tr>
<tr class="separator:a3a5734e32caac22b89766a4b90a1679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4bc166d6d02d43fe5621cdd29c5013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a9d4bc166d6d02d43fe5621cdd29c5013">QTimeEvt_disarm</a> (<a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const me)</td></tr>
<tr class="memdesc:a9d4bc166d6d02d43fe5621cdd29c5013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disarm a time event.  <a href="qf_8h.html#a9d4bc166d6d02d43fe5621cdd29c5013">More...</a><br /></td></tr>
<tr class="separator:a9d4bc166d6d02d43fe5621cdd29c5013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d04658e1c8eec71da5976db433505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a972d04658e1c8eec71da5976db433505">QTimeEvt_wasDisarmed</a> (<a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const me)</td></tr>
<tr class="memdesc:a972d04658e1c8eec71da5976db433505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the "was disarmed" status of a time event.  <a href="qf_8h.html#a972d04658e1c8eec71da5976db433505">More...</a><br /></td></tr>
<tr class="separator:a972d04658e1c8eec71da5976db433505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8fc8c4421ae5131408ca74bd8138de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a5d8fc8c4421ae5131408ca74bd8138de">QTimeEvt_currCtr</a> (<a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> const *const me)</td></tr>
<tr class="memdesc:a5d8fc8c4421ae5131408ca74bd8138de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value of the down-counter of a time event.  <a href="qf_8h.html#a5d8fc8c4421ae5131408ca74bd8138de">More...</a><br /></td></tr>
<tr class="separator:a5d8fc8c4421ae5131408ca74bd8138de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac7eccb860d910c4e446d3143798bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a> (void)</td></tr>
<tr class="memdesc:adac7eccb860d910c4e446d3143798bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">QF initialization.  <a href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">More...</a><br /></td></tr>
<tr class="separator:adac7eccb860d910c4e446d3143798bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a20b07a97300a74383cd863cbfd6bc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">QF_psInit</a> (<a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">QSubscrList</a> *const subscrSto, <a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const maxSignal)</td></tr>
<tr class="memdesc:a3a20b07a97300a74383cd863cbfd6bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish-subscribe initialization.  <a href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">More...</a><br /></td></tr>
<tr class="separator:a3a20b07a97300a74383cd863cbfd6bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4fc5636c2bc2e9d47e958aac05b8e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a> (void *const poolSto, <a class="el" href="16bit_2stdint_8h.html#aeb3ae59c7d101507a3952f5de306ea95">uint_fast32_t</a> const poolSize, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const evtSize)</td></tr>
<tr class="memdesc:a1c4fc5636c2bc2e9d47e958aac05b8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event pool initialization for dynamic allocation of events.  <a href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">More...</a><br /></td></tr>
<tr class="separator:a1c4fc5636c2bc2e9d47e958aac05b8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c89d3e5e55aeeec9175ec95635476ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7c89d3e5e55aeeec9175ec95635476ce">QF_poolGetMaxBlockSize</a> (void)</td></tr>
<tr class="memdesc:a7c89d3e5e55aeeec9175ec95635476ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the block size of any registered event pools.  <a href="qf_8h.html#a7c89d3e5e55aeeec9175ec95635476ce">More...</a><br /></td></tr>
<tr class="separator:a7c89d3e5e55aeeec9175ec95635476ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779a1bc9482e2d489dc87751cd100fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a> (void)</td></tr>
<tr class="memdesc:a779a1bc9482e2d489dc87751cd100fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers control to QF to run the application.  <a href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">More...</a><br /></td></tr>
<tr class="separator:a779a1bc9482e2d489dc87751cd100fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9cb86740bf55c5ad55c1d44fd35921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop</a> (void)</td></tr>
<tr class="memdesc:adf9cb86740bf55c5ad55c1d44fd35921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function invoked by the application layer to stop the QF application and return control to the OS/Kernel.  <a href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921">More...</a><br /></td></tr>
<tr class="separator:adf9cb86740bf55c5ad55c1d44fd35921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189a6d2ece787717c81fbf51fd180732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup</a> (void)</td></tr>
<tr class="memdesc:a189a6d2ece787717c81fbf51fd180732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Startup QF callback.  <a href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732">More...</a><br /></td></tr>
<tr class="separator:a189a6d2ece787717c81fbf51fd180732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7e181f2e679e1fa77c1e915fbee3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup</a> (void)</td></tr>
<tr class="memdesc:a5d7e181f2e679e1fa77c1e915fbee3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup QF callback.  <a href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0">More...</a><br /></td></tr>
<tr class="separator:a5d7e181f2e679e1fa77c1e915fbee3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb533f5e56964494448184a1991f8db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db">QF_publish_</a> (<a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> const *const e, void const *const sender)</td></tr>
<tr class="memdesc:a1fb533f5e56964494448184a1991f8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish event to the framework.  <a href="qf_8h.html#a1fb533f5e56964494448184a1991f8db">More...</a><br /></td></tr>
<tr class="separator:a1fb533f5e56964494448184a1991f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf676a0ed64ab7ed8a8151f1f2e7c82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82">QF_tickX_</a> (<a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const tickRate, void const *const sender)</td></tr>
<tr class="memdesc:a8cf676a0ed64ab7ed8a8151f1f2e7c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <a href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82">More...</a><br /></td></tr>
<tr class="separator:a8cf676a0ed64ab7ed8a8151f1f2e7c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691ef631f5557b516f13f32ca9eb1338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a691ef631f5557b516f13f32ca9eb1338">QF_noTimeEvtsActiveX</a> (<a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const tickRate)</td></tr>
<tr class="memdesc:a691ef631f5557b516f13f32ca9eb1338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 'true' if there are no armed time events at a given tick rate.  <a href="qf_8h.html#a691ef631f5557b516f13f32ca9eb1338">More...</a><br /></td></tr>
<tr class="separator:a691ef631f5557b516f13f32ca9eb1338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438fc360095cdafd2b4ba7f5d65bc9b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a438fc360095cdafd2b4ba7f5d65bc9b0">QF_add_</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const a)</td></tr>
<tr class="memdesc:a438fc360095cdafd2b4ba7f5d65bc9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an active object to be managed by the framework.  <a href="qf_8h.html#a438fc360095cdafd2b4ba7f5d65bc9b0">More...</a><br /></td></tr>
<tr class="separator:a438fc360095cdafd2b4ba7f5d65bc9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b0d9d2c9ad2546fea14975bc1a1328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a35b0d9d2c9ad2546fea14975bc1a1328">QF_remove_</a> (<a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const a)</td></tr>
<tr class="memdesc:a35b0d9d2c9ad2546fea14975bc1a1328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the active object from the framework.  <a href="qf_8h.html#a35b0d9d2c9ad2546fea14975bc1a1328">More...</a><br /></td></tr>
<tr class="separator:a35b0d9d2c9ad2546fea14975bc1a1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52d81b1bd2cab6523fbe13cb5d79190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ae52d81b1bd2cab6523fbe13cb5d79190">QF_getPoolMin</a> (<a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const poolId)</td></tr>
<tr class="memdesc:ae52d81b1bd2cab6523fbe13cb5d79190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the minimum of free entries of the given event pool.  <a href="qf_8h.html#ae52d81b1bd2cab6523fbe13cb5d79190">More...</a><br /></td></tr>
<tr class="separator:ae52d81b1bd2cab6523fbe13cb5d79190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29692c0dcab731199b5beb5847484ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a29692c0dcab731199b5beb5847484ab7">QF_getQueueMin</a> (<a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const prio)</td></tr>
<tr class="memdesc:a29692c0dcab731199b5beb5847484ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the minimum of free entries of the given event queue.  <a href="qf_8h.html#a29692c0dcab731199b5beb5847484ab7">More...</a><br /></td></tr>
<tr class="separator:a29692c0dcab731199b5beb5847484ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c49ff8c7895ca20958de54583a4e9cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">QF_newX_</a> (<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const evtSize, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const margin, <a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const sig)</td></tr>
<tr class="memdesc:a1c49ff8c7895ca20958de54583a4e9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal QF implementation of creating new dynamic event.  <a href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">More...</a><br /></td></tr>
<tr class="separator:a1c49ff8c7895ca20958de54583a4e9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770a14292ba710e2843901dca56cb4bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a770a14292ba710e2843901dca56cb4bb">QF_newRef_</a> (<a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> const *const e, void const *const evtRef)</td></tr>
<tr class="memdesc:a770a14292ba710e2843901dca56cb4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal QF implementation of creating new event reference.  <a href="qf_8h.html#a770a14292ba710e2843901dca56cb4bb">More...</a><br /></td></tr>
<tr class="separator:a770a14292ba710e2843901dca56cb4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb373ddc448c4198e4247b6c6ff3e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aebb373ddc448c4198e4247b6c6ff3e69">QF_deleteRef_</a> (void const *const evtRef)</td></tr>
<tr class="memdesc:aebb373ddc448c4198e4247b6c6ff3e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal QF implementation of deleting event reference.  <a href="qf_8h.html#aebb373ddc448c4198e4247b6c6ff3e69">More...</a><br /></td></tr>
<tr class="separator:aebb373ddc448c4198e4247b6c6ff3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa4e9d39b8af089405cb829e2cc5a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7aa4e9d39b8af089405cb829e2cc5a24">QF_gc</a> (<a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> const *const e)</td></tr>
<tr class="memdesc:a7aa4e9d39b8af089405cb829e2cc5a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycle a dynamic event.  <a href="qf_8h.html#a7aa4e9d39b8af089405cb829e2cc5a24">More...</a><br /></td></tr>
<tr class="separator:a7aa4e9d39b8af089405cb829e2cc5a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5f5f3c33ce2706283cbe8179a9a2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1e5f5f3c33ce2706283cbe8179a9a2c5">QF_bzero</a> (void *const start, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> len)</td></tr>
<tr class="memdesc:a1e5f5f3c33ce2706283cbe8179a9a2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a specified region of memory to zero.  <a href="qf_8h.html#a1e5f5f3c33ce2706283cbe8179a9a2c5">More...</a><br /></td></tr>
<tr class="separator:a1e5f5f3c33ce2706283cbe8179a9a2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199fd259df25c25b190a8a61c3ec3b90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a199fd259df25c25b190a8a61c3ec3b90">QTicker_ctor</a> (<a class="el" href="qf_8h.html#ad83956ec689cb4ccf4732a91c7821894">QTicker</a> *const me, <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> tickRate)</td></tr>
<tr class="memdesc:a199fd259df25c25b190a8a61c3ec3b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the QTicker Active Object class.  <a href="qf_8h.html#a199fd259df25c25b190a8a61c3ec3b90">More...</a><br /></td></tr>
<tr class="separator:a199fd259df25c25b190a8a61c3ec3b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6ece34fc555ade0a6a10a259a6463401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a6ece34fc555ade0a6a10a259a6463401">QF_active_</a> [<a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a>+1U]</td></tr>
<tr class="memdesc:a6ece34fc555ade0a6a10a259a6463401"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of registered active objects  <a href="qf_8h.html#a6ece34fc555ade0a6a10a259a6463401">More...</a><br /></td></tr>
<tr class="separator:a6ece34fc555ade0a6a10a259a6463401"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>QF/C platform-independent public interface. </p>

<p class="definition">Definition in file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_q_active" id="struct_q_active"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_q_active">&#9670;&nbsp;</a></span>QActive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct QActive</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Active Object (based on <a class="el" href="qep_8h.html#struct_q_hsm">QHsm</a> implementation) </p>
<dl class="section user"><dt>Description</dt><dd>Active objects in QP are encapsulated state machines (each embedding an event queue and a thread) that communicate with one another asynchronously by sending and receiving events. Within an active object, events are processed sequentially in a run-to-completion (RTC) fashion, while QF encapsulates all the details of thread-safe event exchange and queuing. <br  />
<br  />
<a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a> represents an active object that uses the QHsm-style implementation strategy for state machines. This strategy is tailored to manual coding, but it is also supported by the QM modeling tool. The resulting code is slower than in the <a class="el" href="qep_8h.html#ad55e90747946de1e62e356ea04f5eaaf" title="QM State Machine implementation strategy.">QMsm</a> style implementation strategy.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates how to derive an active object from <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a>. Please note that the <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a> member <code>super</code> is defined as the <b>first</b> member of the derived struct (see <a class="el" href="index.html#oop">Object Orientation</a>). <div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <a class="code" href="qf_8h.html#struct_q_active">QActive</a> <a class="code" href="qf_8h.html#a292a76f05e6800a383c7615b4c88cd0e">super</a>;    <span class="comment">/* inherits QActive */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> timeEvt; <span class="comment">/* to timeout thining or eating */</span></div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num;      <span class="comment">/* this philosopher&#39;s number */</span></div>
<div class="line">} Philo;</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00114">114</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><div class="dynheader">
Collaboration diagram for QActive:</div>
<div class="dyncontent">
<div class="center"><img src="struct_q_active__coll__graph.png" border="0" usemap="#_q_active_coll__map" alt="Collaboration graph"/></div>
<map name="_q_active_coll__map" id="_q_active_coll__map">
<area shape="rect" title="Active Object (based on QHsm implementation)" alt="" coords="5,197,72,274"/>
<area shape="rect" href="qxthread_8h.html#struct_q_x_thread" title="eXtended (blocking) thread of the QXK preemptive kernel" alt="" coords="82,359,161,436"/>
<area shape="rect" href="qep_8h.html#struct_q_hsm" title=" " alt="" coords="215,668,273,745"/>
<area shape="rect" href="qep_8h.html#union_q_hsm_attr" title="Attribute of for the QHsm class (Hierarchical State Machine)." alt="" coords="204,506,284,583"/>
<area shape="rect" href="qep_8h.html#struct_q_m_state" title="State object for the QMsm class (QM State Machine)." alt="" coords="267,175,373,296"/>
<area shape="rect" href="qep_8h.html#struct_q_m_tran_act_table" title="Transition&#45;Action Table for the Meta State Machine." alt="" coords="185,359,303,436"/>
<area shape="rect" href="qep_8h.html#struct_q_evt" title="Event structure." alt="" coords="363,5,437,112"/>
<area shape="rect" href="qf_8h.html#struct_q_time_evt" title="Time Event structure." alt="" coords="102,182,181,289"/>
<area shape="rect" href="struct_q_hsm_vtable.html" title="Virtual table for the QHsm class." alt="" coords="308,499,404,591"/>
</map>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a292a76f05e6800a383c7615b4c88cd0e"></a><a class="el" href="qep_8h.html#struct_q_hsm">QHsm</a></td>
<td class="fieldname">
super</td>
<td class="fielddoc">
inherits <a class="el" href="qep_8h.html#struct_q_hsm">QHsm</a> </td></tr>
<tr><td class="fieldtype">
<a id="acc0b27a6740f03639727be452f1e6b83"></a><a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></td>
<td class="fieldname">
prio</td>
<td class="fielddoc">
QF priority (1..<a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>) of this active object. </td></tr>
</table>

</div>
</div>
<a name="struct_q_time_evt" id="struct_q_time_evt"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_q_time_evt">&#9670;&nbsp;</a></span>QTimeEvt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct QTimeEvt</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Time Event structure. </p>
<dl class="section user"><dt>Description</dt><dd>Time events are special QF events equipped with the notion of time passage. The basic usage model of the time events is as follows. An active object allocates one or more <a class="el" href="qf_8h.html#struct_q_time_evt" title="Time Event structure.">QTimeEvt</a> objects (provides the storage for them). When the active object needs to arrange for a timeout, it arms one of its time events to fire either just once (one-shot) or periodically. Each time event times out independently from the others, so a QF application can make multiple parallel timeout requests (from the same or different active objects). When QF detects that the appropriate moment has arrived, it inserts the time event directly into the recipient's event queue. The recipient then processes the time event just like any other event.</dd></dl>
<p>Time events, as any other QF events derive from the <a class="el" href="qep_8h.html#struct_q_evt" title="Event structure.">QEvt</a> base structure. Typically, you will use a time event as-is, but you can also further derive more specialized time events from it by adding some more data members and/or specialized functions that operate on the specialized time events.</p>
<p>Internally, the armed time events are organized into linked lists&ndash;one list for every supported ticking rate. These linked lists are scanned in every invocation of the <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a> function. Only armed (timing out) time events are in the list, so only armed time events consume CPU cycles.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#struct_q_time_evt" title="Time Event structure.">QTimeEvt</a> for the description of the data members <br  />
 <a class="el" href="index.html#oop">Object Orientation</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>QF manages the time events in the function <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a>, which must be called periodically, from the clock tick ISR or from the special <a class="el" href="qf_8h.html#ad83956ec689cb4ccf4732a91c7821894" title="QTicker Active Object class.">QTicker</a> active object.</dd>
<dd>
Even though <a class="el" href="qf_8h.html#struct_q_time_evt" title="Time Event structure.">QTimeEvt</a> is a subclass of <a class="el" href="qep_8h.html#struct_q_evt" title="Event structure.">QEvt</a>, <a class="el" href="qf_8h.html#struct_q_time_evt" title="Time Event structure.">QTimeEvt</a> instances can NOT be allocated dynamically from event pools. In other words, it is illegal to allocate <a class="el" href="qf_8h.html#struct_q_time_evt" title="Time Event structure.">QTimeEvt</a> instances with the <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a> or <a class="el" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436" title="Allocate a dynamic event (non-asserting version).">Q_NEW_X()</a> macros. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00442">442</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><div class="dynheader">
Collaboration diagram for QTimeEvt:</div>
<div class="dyncontent">
<div class="center"><img src="struct_q_time_evt__coll__graph.png" border="0" usemap="#_q_time_evt_coll__map" alt="Collaboration graph"/></div>
<map name="_q_time_evt_coll__map" id="_q_time_evt_coll__map">
<area shape="rect" title="Time Event structure." alt="" coords="5,175,84,281"/>
<area shape="rect" href="qep_8h.html#struct_q_evt" title="Event structure." alt="" coords="7,5,82,112"/>
</map>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="abb55c0996b3f57877b1023a6d1a89101"></a><a class="el" href="qep_8h.html#struct_q_evt">QEvt</a></td>
<td class="fieldname">
super</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a0af89bee26e0c6f89e7006904bb27c2c"></a>struct <a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *volatile</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
link to the next time event in the list </td></tr>
<tr><td class="fieldtype">
<a id="a0b1ac98776b4600191b073622f7efc24"></a>void *volatile</td>
<td class="fieldname">
act</td>
<td class="fielddoc">
the active object that receives the time events </td></tr>
<tr><td class="fieldtype">
<a id="a139b8ef35b103acac907b2aa14a00fc7"></a><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a> volatile</td>
<td class="fieldname">
ctr</td>
<td class="fielddoc">
the internal down-counter of the time event. <dl class="section user"><dt>Description</dt><dd>The down-counter is decremented by 1 in every <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a> invocation. The time event fires (gets posted or published) when the down-counter reaches zero. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a53b3919aabc87ac01af63c60e95ac35d"></a><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a></td>
<td class="fieldname">
interval</td>
<td class="fielddoc">
the interval for periodic time event (zero for one-shot time event) <dl class="section user"><dt>Description</dt><dd>The value of the interval is re-loaded to the internal down-counter when the time event expires, so that the time event keeps timing out periodically. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3123ef03f5d66d866da12c736ac574b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3123ef03f5d66d866da12c736ac574b0">&#9670;&nbsp;</a></span>QACTIVE_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_START</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">qSto_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">qLen_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stkSto_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stkLen_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">par_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">    Q_ASSERT((me_)-&gt;super.vptr);                                             \</div>
<div class="line">    (*((<a class="code" href="struct_q_active_vtable.html">QActiveVtable</a> <span class="keyword">const</span> *)((me_)-&gt;super.vptr))-&gt;start)(                  \</div>
<div class="line">        (me_), (prio_), (qSto_), (qLen_), (stkSto_), (stkLen_), (par_));     \</div>
<div class="line">} <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Polymorphically start an active object. </p>
<dl class="section user"><dt>Description</dt><dd>Starts execution of the AO and registers the AO with the framework.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me_</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio_</td><td>priority at which to start the active object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qSto_</td><td>pointer to the storage for the ring buffer of the event queue (used only with the built-in <a class="el" href="qequeue_8h.html#struct_q_e_queue" title="Native QF Event Queue.">QEQueue</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qLen_</td><td>length of the event queue (in events) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stkSto_</td><td>pointer to the stack storage (used only when per-AO stack is needed) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stkSize_</td><td>stack size (in bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">par_</td><td>pointer to the additional port-specific parameter(s) (might be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="qpc_8h.html">qpc.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="qassert_8h.html#a27042866331f49c9e9ff4f3ef459eaaf">Q_DEFINE_THIS_FILE</a></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">static</span> Philo l_philo[N]; <span class="comment">/* N Philo active objects */</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> <span class="keyword">const</span> *l_philQueueSto[N][N]; <span class="comment">/* storage for event queues */</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> l_philoStk[N][256];  <span class="comment">/* stacks for the Philo active objects */</span></div>
<div class="line"> </div>
<div class="line">    . . .</div>
<div class="line">    <span class="keywordflow">for</span> (n = 0; n &lt; N; ++n) {</div>
<div class="line">        TableEvt ie;  <span class="comment">/* initialization event for the Philo SM */</span></div>
<div class="line">        ie.philNum = n;</div>
<div class="line">        Philo_ctor(&amp;l_philo[n]);</div>
<div class="line">        <a class="code" href="qf_8h.html#a3123ef03f5d66d866da12c736ac574b0">QACTIVE_START</a>((<a class="code" href="qf_8h.html#struct_q_active">QActive</a> *)&amp;l_philo[n],  <span class="comment">/* Philo pointer */</span></div>
<div class="line">            (<a class="code" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a>)(n*10 + 1),          <span class="comment">/* priority */</span></div>
<div class="line">            l_philoQueueSto[n], <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]), <span class="comment">/* queue */</span></div>
<div class="line">            l_philoStk[n], <span class="keyword">sizeof</span>(l_philoStk[n]), <span class="comment">/* per AO stack */</span></div>
<div class="line">            &amp;ie.super);                        <span class="comment">/* initialization event */</span></div>
<div class="line">    }</div>
<div class="line">    . . .</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00215">215</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="ab7c56990d949c8708e3fe2b737f2e65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c56990d949c8708e3fe2b737f2e65c">&#9670;&nbsp;</a></span>QACTIVE_POST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_POST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ((void)(*((<a class="code" href="struct_q_active_vtable.html">QActiveVtable</a> <span class="keyword">const</span> *)((me_)-&gt;super.vptr))-&gt;post)((me_), \</div>
<div class="line">                  (e_), <a class="code" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a>, (sender_)))</div>
</div><!-- fragment -->
<p>Polymorphically posts an event to an active object (FIFO) with delivery guarantee. </p>
<dl class="section user"><dt>Description</dt><dd>This macro asserts if the queue overflows and cannot accept the event.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me_</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the event to post </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sendedr_</code> parameter is actually only used when QS tracing is enabled (macro <a class="el" href="macros_8h.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined). When QS software tracing is disenabled, the <a class="el" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c" title="Polymorphically posts an event to an active object (FIFO) with delivery guarantee.">QACTIVE_POST()</a> macro does not pass the <code>sender_</code> argument, so the overhead of passing this extra argument is entirely avoided.</dd>
<dd>
The pointer to the sender object is not necessarily a pointer to an active object. In fact, if <a class="el" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c" title="Polymorphically posts an event to an active object (FIFO) with delivery guarantee.">QACTIVE_POST()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the sender of the event.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a766856b24aa5163b7ca90bc3432f1e3e" title="Polymorphically posts an event to an active object (FIFO) without delivery guarantee.">QACTIVE_POST_X</a>, <a class="el" href="qf__actq_8c.html#a1a81b9fd06d9c0aa5dea32d194f0552b" title="Implementation of the active object post (FIFO) operation.">QActive_post_()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00247">247</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a766856b24aa5163b7ca90bc3432f1e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766856b24aa5163b7ca90bc3432f1e3e">&#9670;&nbsp;</a></span>QACTIVE_POST_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_POST_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">margin_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ((*((<a class="code" href="struct_q_active_vtable.html">QActiveVtable</a> <span class="keyword">const</span> *)((me_)-&gt;super.vptr))-&gt;post)((me_), \</div>
<div class="line">         (e_), (margin_), (sender_)))</div>
</div><!-- fragment -->
<p>Polymorphically posts an event to an active object (FIFO) without delivery guarantee. </p>
<dl class="section user"><dt>Description</dt><dd>This macro does not assert if the queue overflows and cannot accept the event with the specified margin of free slots remaining.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me_</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the event to post </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin_</td><td>the minimum free slots in the queue, which must still be available after posting the event. The special value <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> causes asserting failure in case event allocation fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the posting succeeded, and 'false' if the posting failed due to insufficient margin of free slots available in the queue.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sender_</code> parameter is actually only used when QS tracing is enabled (macro <a class="el" href="macros_8h.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined). When QS software tracing is disabled, the <a class="el" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c" title="Polymorphically posts an event to an active object (FIFO) with delivery guarantee.">QACTIVE_POST()</a> macro does not pass the <code>sender_</code> argument, so the overhead of passing this extra argument is entirely avoided.</dd>
<dd>
The pointer to the sender object is not necessarily a pointer to an active object. In fact, if <a class="el" href="qf_8h.html#a766856b24aa5163b7ca90bc3432f1e3e" title="Polymorphically posts an event to an active object (FIFO) without delivery guarantee.">QACTIVE_POST_X()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the sender of the event.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="qf_8h.html#struct_q_active">QActive</a> *AO_Table;</div>
<div class="line"> </div>
<div class="line">    . . .</div>
<div class="line">    <span class="comment">/* typically inside a state machine action */</span></div>
<div class="line">    TableEvt *pe;</div>
<div class="line">    <a class="code" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a>(pe, TableEvt, 5U, HUNGRY_SIG); <span class="comment">/* dynamic alloc, margin==5 */</span></div>
<div class="line">    <span class="keywordflow">if</span> (pe != (TableEvt *)0) {</div>
<div class="line">        pe-&gt;philNum = me-&gt;num;</div>
<div class="line">        <a class="code" href="qf_8h.html#a766856b24aa5163b7ca90bc3432f1e3e">QACTIVE_POST_X</a>(AO_Table, &amp;pe-&gt;super, 3U, me); <span class="comment">/* margin==3 */</span></div>
<div class="line">    }</div>
<div class="line">    . . .</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00285">285</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a2f94b69fa7148180c19d501ce2ee7032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f94b69fa7148180c19d501ce2ee7032">&#9670;&nbsp;</a></span>QACTIVE_POST_LIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_POST_LIFO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((*((<a class="el" href="struct_q_active_vtable.html">QActiveVtable</a> const *)((me_)-&gt;super.vptr))-&gt;postLIFO)((me_), (e_)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polymorphically posts an event to an active object using the Last-In-First-Out (LIFO) policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me_</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the event to post </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00306">306</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="afd57334f2a1664a168b0702a106e0782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd57334f2a1664a168b0702a106e0782">&#9670;&nbsp;</a></span>QF_PUBLISH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_PUBLISH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="qf__ps_8c.html#a1fb533f5e56964494448184a1991f8db">QF_publish_</a>((e_), (void const *)(sender_)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the event publishing facility <a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>. </p>
<dl class="section user"><dt>Description</dt><dd>This macro is the recommended way of publishing events, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the posted event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object. This argument is actually only used when QS software tracing is enabled (macro <a class="el" href="macros_8h.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined). When QS software tracing is disabled, the macro calls <a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a> without the <code>sender_</code> parameter, so the overhead of passing this extra argument is entirely avoided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the pointer to the sender object is not necessarily a pointer to an active object. In fact, if <a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782" title="Invoke the event publishing facility QF_publish_().">QF_PUBLISH()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the publisher of the event.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00582">582</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a1f1970e16f4d010b5e5b2fd046aac41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1970e16f4d010b5e5b2fd046aac41e">&#9670;&nbsp;</a></span>QF_TICK_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_TICK_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tickRate_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="qf__time_8c.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82">QF_tickX_</a>((tickRate_), (sender_)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the system clock tick processing <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a>. </p>
<dl class="section user"><dt>Description</dt><dd>This macro is the recommended way of invoking clock tick processing, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate</td><td>clock tick rate to be serviced through this call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender</td><td>pointer to the sender object. This argument is actually only used when QS software tracing is enabled (macro <a class="el" href="macros_8h.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When QS software tracing is disabled, the macro calls <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a> without the <code>sender</code> parameter, so the overhead of passing this extra argument is entirely avoided.</dd>
<dd>
The pointer to the sender object is not necessarily a pointer to an active object. In fact, when <a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e" title="Invoke the system clock tick processing QF_tickX_().">QF_TICK_X()</a> is called from an interrupt, you would create a unique object just to unambiguously identify the ISR as the sender of the time events.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example shows how to invoke <a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e" title="Invoke the system clock tick processing QF_tickX_().">QF_TICK_X()</a> for different system tick rates: <div class="fragment"><div class="line"><span class="comment">/* case 1: Interrupt Controller available,</span></div>
<div class="line"><span class="comment">* &quot;unconditional interrupt unlocking&quot; critical section policy</span></div>
<div class="line"><span class="comment">* (nesting of critical sections _not_ allowed)</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">interrupt <span class="keywordtype">void</span> ISR_timer() { <span class="comment">/* entered with interrupts disabled in hardware */</span></div>
<div class="line">    <a class="code" href="qk_2qf__port_8h.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>();  <span class="comment">/* enable interrupts */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(0U, &amp;l_ISR_timer); <span class="comment">/*&lt;-- QF tick processing for rate 0 */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qk_2qf__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>(); <span class="comment">/* disable interrupts again */</span></div>
<div class="line">    <span class="comment">/* send the EOI instruction to the Interrupt Controller */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* case 2: Interrupt Controller not used,</span></div>
<div class="line"><span class="comment">* &quot;saving and restoring interrupt status&quot; critical section policy</span></div>
<div class="line"><span class="comment">* (nesting of critical sections allowed)</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">interrupt <span class="keywordtype">void</span> ISR_timer() {</div>
<div class="line">    <a class="code" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(1U, &amp;l_ISR_timer); <span class="comment">/*&lt;-- QF tick processing for rate 1 */</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00625">625</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a3c1957439cb1ecff92be7b7401bf3159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1957439cb1ecff92be7b7401bf3159">&#9670;&nbsp;</a></span>QF_NO_MARGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_NO_MARGIN&#160;&#160;&#160;((<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)0xFFFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special value of margin that causes asserting failure in case event allocation or event posting fails </p>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00637">637</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a095356f76aa32cb738325abfa55e96fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095356f76aa32cb738325abfa55e96fc">&#9670;&nbsp;</a></span>QF_TICK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_TICK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(0U, (sender_))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the system clock tick processing for rate 0. </p>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00640">640</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="abd823f3a9e8b3206a3460a108d5fa3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd823f3a9e8b3206a3460a108d5fa3e3">&#9670;&nbsp;</a></span>Q_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sig_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ((evtT_ *)<a class="code" href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">QF_newX_</a>((<a class="code" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)<span class="keyword">sizeof</span>(evtT_), \</div>
<div class="line">                           <a class="code" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a>, (sig_)))</div>
</div><!-- fragment -->
<p>Allocate a dynamic event. </p>
<dl class="section user"><dt>Description</dt><dd>The macro calls the internal QF function <a class="el" href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd" title="Internal QF implementation of creating new dynamic event.">QF_newX_()</a> with margin == <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a>, which causes an assertion when the event cannot be successfully allocated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtT_</td><td>event type (class name) of the event to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig_</td><td>signal to assign to the newly allocated event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid event pointer cast to the type <code>evtT_</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If #Q_EVT_CTOR is defined, the <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a> macro becomes variadic and takes all the arguments needed by the constructor of the event class being allocated. The constructor is then called by means of the placement-new operator.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates dynamic allocation of an event: <div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="qf_8h.html#struct_q_active">QActive</a> *AO_Table;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a> Philoso_hungry(Philo * <span class="keyword">const</span> me, <a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> <span class="keyword">const</span> * <span class="keyword">const</span> e) {</div>
<div class="line">    <a class="code" href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a> status;</div>
<div class="line">    <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="qep_8h.html#a20b1ceebb91aea39fcbc633aeae6cd3f">sig</a>) {</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {</div>
<div class="line">            TableEvt *pe = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a>(TableEvt, HUNGRY_SIG); <span class="comment">/* dynamic alloc */</span></div>
<div class="line">            pe-&gt;philNum = me-&gt;num;</div>
<div class="line">            <a class="code" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c">QACTIVE_POST</a>(AO_Table, &amp;pe-&gt;super, me); <span class="comment">/* direct posting */</span></div>
<div class="line">            status = <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a>();</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        . . .</div>
<div class="line">        <span class="keywordflow">default</span>: {</div>
<div class="line">            status = <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc">Q_SUPER</a>(&amp;<a class="code" href="qep_8h.html#ac8ae4728dfab5ce26a907fc624f6e104">QHsm_top</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00706">706</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="aa52b4d3c43a262022392c6e11be06436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52b4d3c43a262022392c6e11be06436">&#9670;&nbsp;</a></span>Q_NEW_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">margin_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sig_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ((e_) = \</div>
<div class="line">        (evtT_ *)<a class="code" href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">QF_newX_</a>((<a class="code" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)<span class="keyword">sizeof</span>(evtT_), (margin_), (sig_)))</div>
</div><!-- fragment -->
<p>Allocate a dynamic event (non-asserting version). </p>
<dl class="section user"><dt>Description</dt><dd>This macro allocates a new event and sets the pointer <code>e_</code>, while leaving at least <code>margin_</code> of events still available in the pool</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtT_</td><td>event type (class name) of the event to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin_</td><td>number of events that must remain available in the given pool after this allocation. The special value <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> causes asserting failure in case event allocation or event posting fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig_</td><td>signal to assign to the newly allocated event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event pointer cast to the type <code>evtT_</code> or NULL if the event cannot be allocated with the specified <code>margin</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If #Q_EVT_CTOR is defined, the <a class="el" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436" title="Allocate a dynamic event (non-asserting version).">Q_NEW_X()</a> macro becomes variadic and takes all the arguments needed by the constructor of the event class being allocated. The constructor is then called and all the extra arguments are passed to it.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates dynamic allocation of an event: <div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="qf_8h.html#struct_q_active">QActive</a> *AO_Table;</div>
<div class="line"> </div>
<div class="line">    . . .</div>
<div class="line">    <span class="comment">/* typically inside a state machine action */</span></div>
<div class="line">    TableEvt *pe;</div>
<div class="line">    <a class="code" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a>(pe, TableEvt, 5U, HUNGRY_SIG); <span class="comment">/* dynamic alloc, margin==5 */</span></div>
<div class="line">    <span class="keywordflow">if</span> (pe != (TableEvt *)0) {</div>
<div class="line">        pe-&gt;philNum = me-&gt;num;</div>
<div class="line">        <a class="code" href="qf_8h.html#a766856b24aa5163b7ca90bc3432f1e3e">QACTIVE_POST_X</a>(AO_Table, &amp;pe-&gt;super, 3U, me); <span class="comment">/* margin==3 */</span></div>
<div class="line">    }</div>
<div class="line">    . . .</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00736">736</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a10162978b156ab5d2fd2e3a7aa744ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10162978b156ab5d2fd2e3a7aa744ac0">&#9670;&nbsp;</a></span>Q_NEW_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtRef_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((evtRef_) = (evtT_ const *)<a class="el" href="qf__dyn_8c.html#a770a14292ba710e2843901dca56cb4bb">QF_newRef_</a>(e, (evtRef_)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new reference of the current event <code>e</code> </p>
<dl class="section user"><dt>Description</dt><dd>The current event processed by an active object is available only for the duration of the run-to-completion (RTC) step. After that step, the current event is no longer available and the framework might recycle (garbage-collect) the event. The macro <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> explicitly creates a new reference to the current event that can be stored and used beyond the current RTC step, until the reference is explicitly recycled by means of the macro <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">evtRef_</td><td>event reference to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtT_</td><td>event type (class name) of the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>The example <b>defer</b> in the directory <code>examples/win32/defer</code> illustrates the use of <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00761">761</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="aaed009a86c52cf2b8d811389fabb5f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed009a86c52cf2b8d811389fabb5f23">&#9670;&nbsp;</a></span>Q_DELETE_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_DELETE_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtRef_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">    QF_deleteRef_((evtRef_));      \</div>
<div class="line">    (evtRef_) = (<span class="keywordtype">void</span> *)0;         \</div>
<div class="line">} <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Delete the event reference. </p>
<dl class="section user"><dt>Description</dt><dd>Every event reference created with the macro <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> needs to be eventually deleted by means of the macro <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a> to avoid leaking the event.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">evtRef_</td><td>event reference to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>The example <b>defer</b> in the directory <code>examples/win32/defer</code> illustrates the use of <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00779">779</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="adc8820f52d450bcfb7d1f830e6c8a8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8820f52d450bcfb7d1f830e6c8a8c2">&#9670;&nbsp;</a></span>QF_CRIT_EXIT_NOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_CRIT_EXIT_NOP</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;((void)0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No-operation for exiting a critical section. </p>
<dl class="section user"><dt>Description</dt><dd>In some QF ports the critical section exit takes effect only on the next machine instruction. If this next instruction is another entry to a critical section, the critical section won't be really exited, but rather the two adjacent critical sections would be merged. The <a class="el" href="qf_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2" title="No-operation for exiting a critical section.">QF_CRIT_EXIT_NOP()</a> macro contains minimal code required to prevent such merging of critical sections in QF ports, in which it can occur. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00802">802</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abbb0c00f8a289282390cbd0173eee21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb0c00f8a289282390cbd0173eee21c">&#9670;&nbsp;</a></span>QEvtSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <a class="el" href="qf_8h.html#abbb0c00f8a289282390cbd0173eee21c">QEvtSize</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00053">53</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="acb6eee6e3b8577f256e4c8de9619e19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6eee6e3b8577f256e4c8de9619e19c">&#9670;&nbsp;</a></span>QMActive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="qf_8h.html#struct_q_active">QActive</a> <a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c">QMActive</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QMActive active object (based on <a class="el" href="qep_8h.html#ad55e90747946de1e62e356ea04f5eaaf" title="QM State Machine implementation strategy.">QMsm</a> implementation) </p>
<dl class="section user"><dt>Description</dt><dd>QMActive represents an active object that uses the <a class="el" href="qep_8h.html#ad55e90747946de1e62e356ea04f5eaaf" title="QM State Machine implementation strategy.">QMsm</a> style state machine implementation strategy. This strategy requires the use of the QM modeling tool to generate state machine code automatically, but the code is faster than in the <a class="el" href="qep_8h.html#struct_q_hsm">QHsm</a> style implementation strategy and needs less run-time support (smaller event-processor).</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> is not intended to be instantiated directly, but rather serves as the base class for derivation of active objects in the application.</dd>
<dd>
<a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> inherits <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a> exactly, without adding any new attributes (or operations) and therefore, <a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> is typedef'ed as <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a>. <a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> is not intended to be instantiated directly, but rather serves as the base class for derivation of active objects in the application.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a></dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates how to derive an active object from <a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a>. Please note that the <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a> member <code>super</code> is defined as the <b>first</b> member of the derived struct (see <a class="el" href="index.html#oop">Object Orientation</a>). <div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <a class="code" href="qf_8h.html#struct_q_active">QMActive</a> super;   <span class="comment">/* inherits QMActive */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> timeEvt; <span class="comment">/* to timeout thining or eating */</span></div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num;      <span class="comment">/* this philosopher&#39;s number */</span></div>
<div class="line">} Philo;</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00369">369</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a001ae90801798660dc4c3aea59bfcbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ae90801798660dc4c3aea59bfcbba">&#9670;&nbsp;</a></span>QMActiveVtable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_q_active_vtable.html">QActiveVtable</a> <a class="el" href="qf_8h.html#a001ae90801798660dc4c3aea59bfcbba">QMActiveVtable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual Table for the <a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> class (inherited from <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> inherits <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a> exactly, without adding any new virtual functions and therefore, <a class="el" href="qf_8h.html#a001ae90801798660dc4c3aea59bfcbba" title="Virtual Table for the QMActive class (inherited from QActiveVtable.">QMActiveVtable</a> is typedef'ed as <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00377">377</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a1f3526b0c899ab9687db250ab58551e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3526b0c899ab9687db250ab58551e0">&#9670;&nbsp;</a></span>QTimeEvtCtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00385">385</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a1532f57deb6a85353b9c04bf054fec77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1532f57deb6a85353b9c04bf054fec77">&#9670;&nbsp;</a></span>QSubscrList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="qpset_8h.html#struct_q_p_set">QPSet</a> <a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">QSubscrList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscriber-List structure. </p>
<dl class="section user"><dt>Description</dt><dd>This data type represents a set of active objects that subscribe to a given signal. The set is represented as a priority-set, where each bit corresponds to the unique priority of an active object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77" title="Subscriber-List structure.">QSubscrList</a> for the description of the data members </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00505">505</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="ad83956ec689cb4ccf4732a91c7821894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83956ec689cb4ccf4732a91c7821894">&#9670;&nbsp;</a></span>QTicker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="qf_8h.html#struct_q_active">QActive</a> <a class="el" href="qf_8h.html#ad83956ec689cb4ccf4732a91c7821894">QTicker</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QTicker Active Object class. </p>
<dl class="section user"><dt>Description</dt><dd>The QTicker is an efficient active object specialized to process QF system clock tick at a specified tick frequency [0..QF_MAX_TICK_RATE]. Placing system clock tick processing in an active object allows you to remove the non-deterministic QF::TICK_X() processing from the interrupt level and move it into the thread-level, where you can prioritize it as low as you wish. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00823">823</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a13edf5eeb78176195720ac88bf70b3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13edf5eeb78176195720ac88bf70b3ef">&#9670;&nbsp;</a></span>QActive_ctor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_ctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#a797a6e3e20119fcb0911cffb94e49543">QStateHandler</a>&#160;</td>
          <td class="paramname"><em>initial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>protected "constructor" of an <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a> active object </p>
<dl class="section user"><dt>Description</dt><dd>Performs the first step of active object initialization by assigning the virtual pointer and calling the superclass constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial</td><td>pointer to the event to be dispatched to the MSM</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be called only <b>once</b> before <a class="el" href="qpc_8h.html#a3f4ede7ae922aa2c749176f9269c1ba6">QMSM_INIT()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qep_8h.html#ae19d961a526968a622ecab1b8bd08058" title="Protected &quot;constructor&quot; of QMsm.">QMsm_ctor()</a> and <a class="el" href="qep_8h.html#a3e1d1635d8a7f2247272bb425d8839b8" title="Protected &quot;constructor&quot; of QHsm.">QHsm_ctor()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__qact_8c_source.html#l00066">66</a> of file <a class="el" href="qf__qact_8c_source.html">qf_qact.c</a>.</p>

</div>
</div>
<a id="ae2510a52f1185e2561fa78323983c04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2510a52f1185e2561fa78323983c04d">&#9670;&nbsp;</a></span>QActive_subscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes for delivery of signal <code>sig</code> to the active object <code>me</code>. </p>
<dl class="section user"><dt>Description</dt><dd>This function is part of the Publish-Subscribe event delivery mechanism available in QF. Subscribing to an event means that the framework will start posting all published events with a given signal <code>sig</code> to the event queue of the active object <code>me</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>event signal to subscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>The following example shows how the Table active object subscribes to three signals in the initial transition: <div class="fragment"><div class="line"><a class="code" href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a> Table_initial(Table * <span class="keyword">const</span> me, <a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> <span class="keyword">const</span> * <span class="keyword">const</span> e) {</div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> n;</div>
<div class="line">    (void)e; <span class="comment">/* suppress the compiler warning */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qf_8h.html#ae2510a52f1185e2561fa78323983c04d">QActive_subscribe</a>(&amp;me-&gt;super, HUNGRY_SIG); <span class="comment">/* subscribe to HUNGRY */</span></div>
<div class="line">    <a class="code" href="qf_8h.html#ae2510a52f1185e2561fa78323983c04d">QActive_subscribe</a>(&amp;me-&gt;super, DONE_SIG);   <span class="comment">/*... to DONE */</span></div>
<div class="line">    <a class="code" href="qf_8h.html#ae2510a52f1185e2561fa78323983c04d">QActive_subscribe</a>(&amp;me-&gt;super, TERMINATE_SIG); <span class="comment">/*...and to TERMINATE */</span></div>
<div class="line">    <span class="keywordflow">for</span> (n = 0; n &lt; N; ++n) {</div>
<div class="line">        me-&gt;fork[n] = FREE;</div>
<div class="line">        me-&gt;isHungry[n] = 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50">Q_TRAN</a>(&amp;Table_serving);</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__ps_8c.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>, <a class="el" href="qf__ps_8c.html#a0cf08b1345a60cb4cd2d580f448f819d" title="Un-subscribes from the delivery of signal sig to the AO me.">QActive_unsubscribe()</a>, and <a class="el" href="qf__ps_8c.html#aec64ea18ec1909aa5ce20ca1c154bea4" title="Un-subscribes from the delivery of all signals to the AO me.">QActive_unsubscribeAll()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__ps_8c_source.html#l00206">206</a> of file <a class="el" href="qf__ps_8c_source.html">qf_ps.c</a>.</p>

</div>
</div>
<a id="a0cf08b1345a60cb4cd2d580f448f819d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf08b1345a60cb4cd2d580f448f819d">&#9670;&nbsp;</a></span>QActive_unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Un-subscribes from the delivery of signal <code>sig</code> to the AO <code>me</code>. </p>
<dl class="section user"><dt>Description</dt><dd>This function is part of the Publish-Subscribe event delivery mechanism available in QF. Un-subscribing from an event means that the framework will stop posting published events with a given signal <code>sig</code> to the event queue of the active object <code>me</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>event signal to unsubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Due to the latency of event queues, an active object should NOT assume that a given signal <code>sig</code> will never be dispatched to the state machine of the active object after un-subscribing from that signal. The event might be already in the queue, or just about to be posted and the un-subscribe operation will not flush such events.</dd>
<dd>
Un-subscribing from a signal that has never been subscribed in the first place is considered an error and QF will raise an assertion.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__ps_8c.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>, <a class="el" href="qf__ps_8c.html#ae2510a52f1185e2561fa78323983c04d" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe()</a>, and <a class="el" href="qf__ps_8c.html#aec64ea18ec1909aa5ce20ca1c154bea4" title="Un-subscribes from the delivery of all signals to the AO me.">QActive_unsubscribeAll()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the singal and the prioriy must be in ragne, the AO must also be registered with the framework</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__ps_8c_source.html#l00255">255</a> of file <a class="el" href="qf__ps_8c_source.html">qf_ps.c</a>.</p>

</div>
</div>
<a id="aec64ea18ec1909aa5ce20ca1c154bea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec64ea18ec1909aa5ce20ca1c154bea4">&#9670;&nbsp;</a></span>QActive_unsubscribeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_unsubscribeAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Un-subscribes from the delivery of all signals to the AO <code>me</code>. </p>
<dl class="section user"><dt>Description</dt><dd>This function is part of the Publish-Subscribe event delivery mechanism available in QF. Un-subscribing from all events means that the framework will stop posting any published events to the event queue of the active object <code>me</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Due to the latency of event queues, an active object should NOT assume that no events will ever be dispatched to the state machine of the active object after un-subscribing from all events. The events might be already in the queue, or just about to be posted and the un-subscribe operation will not flush such events. Also, the alternative event-delivery mechanisms, such as direct event posting or time events, can be still delivered to the event queue of the active object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__ps_8c.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>, <a class="el" href="qf__ps_8c.html#ae2510a52f1185e2561fa78323983c04d" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe()</a>, and <a class="el" href="qf__ps_8c.html#a0cf08b1345a60cb4cd2d580f448f819d" title="Un-subscribes from the delivery of signal sig to the AO me.">QActive_unsubscribe()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__ps_8c_source.html#l00304">304</a> of file <a class="el" href="qf__ps_8c_source.html">qf_ps.c</a>.</p>

</div>
</div>
<a id="a57469f44aa23b185fbe4688f35a1a090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57469f44aa23b185fbe4688f35a1a090">&#9670;&nbsp;</a></span>QActive_defer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QActive_defer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qequeue_8h.html#struct_q_e_queue">QEQueue</a> *const&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defer an event <code>e</code> to a given event queue <code>eq</code>. </p>
<dl class="section user"><dt>Description</dt><dd>This function is part of the event deferral support. An active object uses this function to defer an event <code>e</code> to the QF-supported native event queue <code>eq</code>. QF correctly accounts for another outstanding reference to the event and will not recycle the event at the end of the RTC step. Later, the active object might recall one event at a time from the event queue.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eq</td><td>pointer to a "raw" thread-safe queue to recall an event from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the event to be deferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' (success) when the event could be deferred and 'false' (failure) if event deferral failed due to overflowing the queue.</dd></dl>
<p>An active object can use multiple event queues to defer events of different kinds.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__defer_8c.html#a2036d245c002aae06a8a0bb28799d45f" title="Recall a deferred event from a given event queue eq.">QActive_recall()</a>, <a class="el" href="qequeue_8h.html#struct_q_e_queue" title="Native QF Event Queue.">QEQueue</a>, <a class="el" href="qf__defer_8c.html#ad408065e3bbdde9ed07403432a5ba5c4" title="Flush the specified deferred queue eq.">QActive_flushDeferred()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__defer_8c_source.html#l00078">78</a> of file <a class="el" href="qf__defer_8c_source.html">qf_defer.c</a>.</p>

</div>
</div>
<a id="a2036d245c002aae06a8a0bb28799d45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2036d245c002aae06a8a0bb28799d45f">&#9670;&nbsp;</a></span>QActive_recall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QActive_recall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qequeue_8h.html#struct_q_e_queue">QEQueue</a> *const&#160;</td>
          <td class="paramname"><em>eq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recall a deferred event from a given event queue <code>eq</code>. </p>
<dl class="section user"><dt>Description</dt><dd>This function is part of the event deferral support. An active object uses this function to recall a deferred event from a given QF event queue. Recalling an event means that it is removed from the deferred event queue <code>eq</code> and posted (LIFO) to the event queue of the active object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eq</td><td>pointer to a "raw" thread-safe queue to recall an event from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if an event has been recalled and 'false' if not.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An active object can use multiple event queues to defer events of different kinds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__defer_8c.html#a2036d245c002aae06a8a0bb28799d45f" title="Recall a deferred event from a given event queue eq.">QActive_recall()</a>, <a class="el" href="qequeue_8h.html#struct_q_e_queue" title="Native QF Event Queue.">QEQueue</a>, <a class="el" href="qf_8h.html#a2f94b69fa7148180c19d501ce2ee7032" title="Polymorphically posts an event to an active object using the Last-In-First-Out (LIFO) policy.">QACTIVE_POST_LIFO()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__defer_8c_source.html#l00119">119</a> of file <a class="el" href="qf__defer_8c_source.html">qf_defer.c</a>.</p>

</div>
</div>
<a id="ad408065e3bbdde9ed07403432a5ba5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad408065e3bbdde9ed07403432a5ba5c4">&#9670;&nbsp;</a></span>QActive_flushDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> QActive_flushDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> const *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qequeue_8h.html#struct_q_e_queue">QEQueue</a> *const&#160;</td>
          <td class="paramname"><em>eq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the specified deferred queue <code>eq</code>. </p>
<dl class="section user"><dt>Description</dt><dd>This function is part of the event deferral support. An active object can use this function to flush a given QF event queue. The function makes sure that the events are not leaked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eq</td><td>pointer to a "raw" thread-safe queue to flush.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events actually flushed from the queue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__defer_8c.html#a57469f44aa23b185fbe4688f35a1a090" title="Defer an event e to a given event queue eq.">QActive_defer()</a>, <a class="el" href="qf__defer_8c.html#a2036d245c002aae06a8a0bb28799d45f" title="Recall a deferred event from a given event queue eq.">QActive_recall()</a>, <a class="el" href="qequeue_8h.html#struct_q_e_queue" title="Native QF Event Queue.">QEQueue</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__defer_8c_source.html#l00190">190</a> of file <a class="el" href="qf__defer_8c_source.html">qf_defer.c</a>.</p>

</div>
</div>
<a id="a4cbac2dae55570a9bca8a4d6f1f72bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbac2dae55570a9bca8a4d6f1f72bd1">&#9670;&nbsp;</a></span>QActive_setAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_setAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a>&#160;</td>
          <td class="paramname"><em>attr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>attr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic setting of additional attributes (useful in QP ports) </p>

</div>
</div>
<a id="a11417cfd658a571c1b21a47e261b58be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11417cfd658a571c1b21a47e261b58be">&#9670;&nbsp;</a></span>QMActive_ctor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QMActive_ctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c">QMActive</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#a797a6e3e20119fcb0911cffb94e49543">QStateHandler</a>&#160;</td>
          <td class="paramname"><em>initial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>protected "constructor" of an <a class="el" href="qf_8h.html#acb6eee6e3b8577f256e4c8de9619e19c" title="QMActive active object (based on QMsm implementation)">QMActive</a> active object. </p>
<dl class="section user"><dt>Description</dt><dd>Performs the first step of active object initialization by assigning the virtual pointer and calling the superclass constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial</td><td>pointer to the event to be dispatched to the MSM</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be called only ONCE before <a class="el" href="qpc_8h.html#a3f4ede7ae922aa2c749176f9269c1ba6">QMSM_INIT()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qep_8h.html#a3e1d1635d8a7f2247272bb425d8839b8" title="Protected &quot;constructor&quot; of QHsm.">QHsm_ctor()</a> and <a class="el" href="qpc_8h.html#a1ca75ca36a498c57968a887b9ec2d32f">QFsm_ctor()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>QMActive inherits <a class="el" href="qf_8h.html#struct_q_active" title="Active Object (based on QHsm implementation)">QActive</a>, so by the <a class="el" href="index.html#oop">Object Orientation</a> convention it should call the constructor of the superclass, i.e., <a class="el" href="qf_8h.html#a13edf5eeb78176195720ac88bf70b3ef" title="protected &quot;constructor&quot; of an QActive active object">QActive_ctor()</a>. However, this would pull in the <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>, which in turn will pull in the code for <a class="el" href="qep_8h.html#ac62dcdecb18497d6fae1c1ad4892b3e7" title="Implementation of the top-most initial transition in QHsm subclass.">QHsm_init_()</a> and <a class="el" href="qep_8h.html#a5cb4c75edd319e677444a477d6d79af4" title="Implementation of dispatching events to a QHsm subclass.">QHsm_dispatch_()</a> implemetations, which is expensive. To avoid this code size penalty, in case <a class="el" href="qep_8h.html#struct_q_hsm">QHsm</a> is not used in a given project, the call to <a class="el" href="qep_8h.html#ae19d961a526968a622ecab1b8bd08058" title="Protected &quot;constructor&quot; of QMsm.">QMsm_ctor()</a> avoids pulling in the code for <a class="el" href="qep_8h.html#struct_q_hsm">QHsm</a>.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__qmact_8c_source.html#l00067">67</a> of file <a class="el" href="qf__qmact_8c_source.html">qf_qmact.c</a>.</p>

</div>
</div>
<a id="a790b654800908426f563112107b11647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790b654800908426f563112107b11647">&#9670;&nbsp;</a></span>QTimeEvt_ctorX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QTimeEvt_ctorX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const&#160;</td>
          <td class="paramname"><em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a>&#160;</td>
          <td class="paramname"><em>tickRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The extended "constructor" to initialize a Time Event. </p>
<dl class="section user"><dt>Description</dt><dd>When creating a time event, you must commit it to a specific active object <code>act</code>, tick rate <code>tickRate</code> and event signal <code>sig</code>. You cannot change these attributes later.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">act</td><td>pointer to the active object associated with this time event. The time event will post itself to this AO. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>signal to associate with this time event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate</td><td>systemclock tick rate to associate with this time event in the range [0..15].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>You should call the constructor exactly once for every Time Event object <b>before</b> arming the Time Event. The ideal place for initializing the time event(s) associated with a given AO is the AO's constructor. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The signal must be valid and the tick rate in range</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00239">239</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a9bbcb00315fb8bb8641003b2b2d07ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbcb00315fb8bb8641003b2b2d07ce4">&#9670;&nbsp;</a></span>QTimeEvt_armX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QTimeEvt_armX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a> const&#160;</td>
          <td class="paramname"><em>nTicks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a> const&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arm a time event (one shot or periodic) for direct event posting. </p>
<dl class="section user"><dt>Description</dt><dd>Arms a time event to fire in a specified number of clock ticks and with a specified interval. If the interval is zero, the time event is armed for one shot ('one-shot' time event). The time event gets directly posted (using the FIFO policy) into the event queue of the host active object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nTicks</td><td>number of clock ticks (at the associated rate) to rearm the time event with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>interval (in clock ticks) for periodic time event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After posting, a one-shot time event gets automatically disarmed while a periodic time event (interval != 0) is automatically re-armed.</dd>
<dd>
A time event can be disarmed at any time by calling the <a class="el" href="qf__time_8c.html#a9d4bc166d6d02d43fe5621cdd29c5013" title="Disarm a time event.">QTimeEvt_disarm()</a> function. Also, a time event can be re-armed to fire in a different number of clock ticks by calling the <a class="el" href="qf__time_8c.html#a3a5734e32caac22b89766a4b90a1679b" title="Rearm a time event.">QTimeEvt_rearm()</a> function.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example shows how to arm a one-shot time event from a state machine of an active object: <div class="fragment"><div class="line"><a class="code" href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a> Philo_eating(Philo * <span class="keyword">const</span> me, <a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> <span class="keyword">const</span> * <span class="keyword">const</span> e) {</div>
<div class="line">    <a class="code" href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a> status;</div>
<div class="line">    <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="qep_8h.html#a20b1ceebb91aea39fcbc633aeae6cd3f">sig</a>) {</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {</div>
<div class="line">            <a class="code" href="qf_8h.html#a9bbcb00315fb8bb8641003b2b2d07ce4">QTimeEvt_armX</a>(&amp;me-&gt;timeEvt, EAT_TIME, 0U); <span class="comment">/* one shot */</span></div>
<div class="line">            status = <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a>();</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ab54538c21a62926a2f1d63d8fd45bf5c">Q_EXIT_SIG</a>: {</div>
<div class="line">            TableEvt *pe;</div>
<div class="line">            <a class="code" href="qf_8h.html#a9d4bc166d6d02d43fe5621cdd29c5013">QTimeEvt_disarm</a>(&amp;me-&gt;timeEvt);</div>
<div class="line">            pe = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a>(TableEvt, DONE_SIG);</div>
<div class="line">            pe-&gt;philNum = me-&gt;num;</div>
<div class="line">            <a class="code" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782">QF_PUBLISH</a>((<a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> *)pe, me);</div>
<div class="line">            status = <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a>();</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">case</span> TIMEOUT_SIG: {</div>
<div class="line">            status = <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50">Q_TRAN</a>(&amp;Philosopher_thinking);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">default</span>: {</div>
<div class="line">            status = <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc">Q_SUPER</a>(&amp;<a class="code" href="qep_8h.html#ac8ae4728dfab5ce26a907fc624f6e104">QHsm_top</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the host AO must be valid, time evnet must be disarmed, number of clock ticks cannot be zero, and the signal must be valid.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00298">298</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a3a5734e32caac22b89766a4b90a1679b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5734e32caac22b89766a4b90a1679b">&#9670;&nbsp;</a></span>QTimeEvt_rearm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QTimeEvt_rearm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a> const&#160;</td>
          <td class="paramname"><em>nTicks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearm a time event. </p>
<dl class="section user"><dt>Description</dt><dd>Rearms a time event with a new number of clock ticks. This function can be used to adjust the current period of a periodic time event or to prevent a one-shot time event from expiring (e.g., a watchdog time event). Rearming a periodic timer leaves the interval unchanged and is a convenient method to adjust the phasing of a periodic time event.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nTicks</td><td>number of clock ticks (at the associated rate) to rearm the time event with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the time event was running as it was re-armed. The 'false' return means that the time event was not truly rearmed because it was not running. The 'false' return is only possible for one-shot time events that have been automatically disarmed upon expiration. In this case the 'false' return means that the time event has already been posted or published and should be expected in the active object's state machine. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>AO must be valid, tick rate must be in range, nTicks must not be zero, and the signal of this time event must be valid</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00433">433</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a9d4bc166d6d02d43fe5621cdd29c5013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4bc166d6d02d43fe5621cdd29c5013">&#9670;&nbsp;</a></span>QTimeEvt_disarm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QTimeEvt_disarm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disarm a time event. </p>
<dl class="section user"><dt>Description</dt><dd>Disarm the time event so it can be safely reused.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the time event was truly disarmed, that is, it was running. The return of 'false' means that the time event was not truly disarmed, because it was not running. The 'false' return is only possible for one- shot time events that have been automatically disarmed upon expiration. In this case the 'false' return means that the time event has already been posted or published and should be expected in the active object's state machine.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>there is no harm in disarming an already disarmed time event </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00372">372</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a972d04658e1c8eec71da5976db433505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972d04658e1c8eec71da5976db433505">&#9670;&nbsp;</a></span>QTimeEvt_wasDisarmed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QTimeEvt_wasDisarmed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the "was disarmed" status of a time event. </p>
<dl class="section user"><dt>Description</dt><dd>Useful for checking whether a one-shot time event was disarmed in the <a class="el" href="qf__time_8c.html#a9d4bc166d6d02d43fe5621cdd29c5013" title="Disarm a time event.">QTimeEvt_disarm()</a> operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the time event was truly disarmed in the last <a class="el" href="qf__time_8c.html#a9d4bc166d6d02d43fe5621cdd29c5013" title="Disarm a time event.">QTimeEvt_disarm()</a> operation. The 'false' return means that the time event was not truly disarmed, because it was not running at that time. The 'false' return is only possible for one-shot time events that have been automatically disarmed upon expiration. In this case the 'false' return means that the time event has already been posted or published and should be expected in the active object's event queue.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has a <b>side effect</b> of setting the "was disarmed" status, which means that the second and subsequent times this function is called the function will return 'true'. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00513">513</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a5d8fc8c4421ae5131408ca74bd8138de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8fc8c4421ae5131408ca74bd8138de">&#9670;&nbsp;</a></span>QTimeEvt_currCtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a> QTimeEvt_currCtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_time_evt">QTimeEvt</a> const *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current value of the down-counter of a time event. </p>
<dl class="section user"><dt>Description</dt><dd>Useful for checking how many clock ticks (at the tick rate associated with the time event) remain until the time event expires.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For an armed time event, the function returns the current value of the down-counter of the given time event. If the time event is not armed, the function returns 0.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function is thread-safe. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00535">535</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="adac7eccb860d910c4e446d3143798bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac7eccb860d910c4e446d3143798bba">&#9670;&nbsp;</a></span>QF_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QF initialization. </p>
<dl class="section user"><dt>Description</dt><dd>Initializes QF and must be called exactly once before any other QF function. Typically, <a class="el" href="qv_8c.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> is called from main() even before initializing the Board Support Package (BSP).</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="qv_8c.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> clears the internal QF variables, so that the framework can start correctly even if the startup code fails to clear the uninitialized data (as is required by the C Standard). </dd></dl>

<p class="definition">Definition at line <a class="el" href="qutest_8c_source.html#l00056">56</a> of file <a class="el" href="qutest_8c_source.html">qutest.c</a>.</p>

</div>
</div>
<a id="a3a20b07a97300a74383cd863cbfd6bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a20b07a97300a74383cd863cbfd6bc6">&#9670;&nbsp;</a></span>QF_psInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_psInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">QSubscrList</a> *const&#160;</td>
          <td class="paramname"><em>subscrSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const&#160;</td>
          <td class="paramname"><em>maxSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish-subscribe initialization. </p>
<dl class="section user"><dt>Description</dt><dd>This function initializes the publish-subscribe facilities of QF and must be called exactly once before any subscriptions/publications occur in the application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscrSto</td><td>pointer to the array of subscriber lists </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSignal</td><td>the dimension of the subscriber array and at the same time the maximum signal that can be published or subscribed.</td></tr>
  </table>
  </dd>
</dl>
<p>The array of subscriber-lists is indexed by signals and provides a mapping between the signals and subscriber-lists. The subscriber-lists are bitmasks of type <a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77" title="Subscriber-List structure.">QSubscrList</a>, each bit in the bit mask corresponding to the unique priority of an active object. The size of the <a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77" title="Subscriber-List structure.">QSubscrList</a> bit mask depends on the value of the <a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>The publish-subscribe facilities are optional, meaning that you might choose not to use publish-subscribe. In that case calling <a class="el" href="qf__ps_8c.html#a3a20b07a97300a74383cd863cbfd6bc6" title="Publish-subscribe initialization.">QF_psInit()</a> and using up memory for the subscriber-lists is unnecessary.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77" title="Subscriber-List structure.">QSubscrList</a></dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example shows the typical initialization sequence of QF: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="qpc_8h.html">qpc.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="qassert_8h.html#a27042866331f49c9e9ff4f3ef459eaaf">Q_DEFINE_THIS_FILE</a></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> <span class="keyword">const</span> *l_tableQueueSto[N_PHILO];</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> <span class="keyword">const</span> *l_philoQueueSto[N_PHILO][N_PHILO];</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="qpset_8h.html#struct_q_p_set">QSubscrList</a> l_subscrSto[MAX_PUB_SIG];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* storage for event pools... */</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="qmpool_8h.html#ab0fe475154021674f904c52e61e78841">QF_MPOOL_EL</a>(TableEvt) l_smlPoolSto[2*N_PHILO]; <span class="comment">/* small pool */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> n;</div>
<div class="line"> </div>
<div class="line">    Philo_ctor(); <span class="comment">/* instantiate all Philosopher active objects */</span></div>
<div class="line">    Table_ctor(); <span class="comment">/* instantiate the Table active object */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a>();  <span class="comment">/* initialize the framework and the underlying RT kernel */</span></div>
<div class="line">    BSP_init(); <span class="comment">/* initialize the BSP */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* send object dictionaries for event pools... */</span></div>
<div class="line">    <a class="code" href="qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(l_smlPoolSto);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* init publish-subscribe... */</span></div>
<div class="line">    <a class="code" href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">QF_psInit</a>(l_subscrSto, <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_subscrSto));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialize event pools... */</span></div>
<div class="line">    <a class="code" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a>(l_smlPoolSto, <span class="keyword">sizeof</span>(l_smlPoolSto), <span class="keyword">sizeof</span>(l_smlPoolSto[0]));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* start the active objects... */</span></div>
<div class="line">    <span class="keywordflow">for</span> (n = 0; n &lt; N_PHILO; ++n) {</div>
<div class="line">        <a class="code" href="qf_8h.html#a3123ef03f5d66d866da12c736ac574b0">QACTIVE_START</a>(AO_Philo[n], (<a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>)(n + 1),</div>
<div class="line">                      l_philoQueueSto[n], <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]),</div>
<div class="line">                      (<span class="keywordtype">void</span> *)0, 0U, (<a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> *)0);</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="qf_8h.html#a3123ef03f5d66d866da12c736ac574b0">QACTIVE_START</a>(AO_Table, (<a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>)(N_PHILO + 1),</div>
<div class="line">                  l_tableQueueSto, <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_tableQueueSto),</div>
<div class="line">                  (<span class="keywordtype">void</span> *)0, 0U, (<a class="code" href="qep_8h.html#struct_q_evt">QEvt</a> *)0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a>(); <span class="comment">/* run the QF application, QF_run() does not return  */</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__ps_8c_source.html#l00087">87</a> of file <a class="el" href="qf__ps_8c_source.html">qf_ps.c</a>.</p>

</div>
</div>
<a id="a1c4fc5636c2bc2e9d47e958aac05b8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4fc5636c2bc2e9d47e958aac05b8e1">&#9670;&nbsp;</a></span>QF_poolInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_poolInit </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>poolSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#aeb3ae59c7d101507a3952f5de306ea95">uint_fast32_t</a> const&#160;</td>
          <td class="paramname"><em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>evtSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event pool initialization for dynamic allocation of events. </p>
<dl class="section user"><dt>Description</dt><dd>This function initializes one event pool at a time and must be called exactly once for each event pool before the pool can be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poolSto</td><td>pointer to the storage for the event pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poolSize</td><td>size of the storage for the pool in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtSize</td><td>the block-size of the pool in bytes, which determines the maximum size of events that can be allocated from the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>You might initialize many event pools by making many consecutive calls to the <a class="el" href="qf__dyn_8c.html#a1c4fc5636c2bc2e9d47e958aac05b8e1" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> function. However, for the simplicity of the internal implementation, you must initialize event pools in the <b>ascending order</b> of the event size.</dd></dl>
<p>Many RTOSes provide fixed block-size heaps, a.k.a. memory pools that can be adapted for QF event pools. In case such support is missing, QF provides a native QF event pool implementation. The macro <a class="el" href="qxk_8h.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a> determines the type of event pool used by a particular QF port. See structure <a class="el" href="qmpool_8h.html#struct_q_m_pool" title="Native QF Memory Pool.">QMPool</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The actual number of events available in the pool might be actually less than (<code>poolSize</code> / <code>evtSize</code>) due to the internal alignment of the blocks that the pool might perform. You can always check the capacity of the pool by calling <a class="el" href="qf_8h.html#ae52d81b1bd2cab6523fbe13cb5d79190" title="Obtain the minimum of free entries of the given event pool.">QF_getPoolMin()</a>.</dd>
<dd>
The dynamic allocation of events is optional, meaning that you might choose not to use dynamic events. In that case calling <a class="el" href="qf__dyn_8c.html#a1c4fc5636c2bc2e9d47e958aac05b8e1" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> and using up memory for the memory blocks is unnecessary.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>QF initialization example for <a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>cannot exceed the number of available memory pools</dd>
<dd>
please initialize event pools in ascending order of evtSize:</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00113">113</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a7c89d3e5e55aeeec9175ec95635476ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c89d3e5e55aeeec9175ec95635476ce">&#9670;&nbsp;</a></span>QF_poolGetMaxBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> QF_poolGetMaxBlockSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the block size of any registered event pools. </p>
<dl class="section user"><dt>Description</dt><dd>Obtain the block size of any registered event pools </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00338">338</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a779a1bc9482e2d489dc87751cd100fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779a1bc9482e2d489dc87751cd100fdb">&#9670;&nbsp;</a></span>QF_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a> QF_run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfers control to QF to run the application. </p>
<dl class="section user"><dt>Description</dt><dd><a class="el" href="qv_8c.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a> is typically called from main() after you initialize the QF and start at least one active object with <a class="el" href="qf_8h.html#a3123ef03f5d66d866da12c736ac574b0" title="Polymorphically start an active object.">QACTIVE_START()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>In QV, the <a class="el" href="qv_8c.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a> function does not return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qutest_8c_source.html#l00074">74</a> of file <a class="el" href="qutest_8c_source.html">qutest.c</a>.</p>

</div>
</div>
<a id="adf9cb86740bf55c5ad55c1d44fd35921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9cb86740bf55c5ad55c1d44fd35921">&#9670;&nbsp;</a></span>QF_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function invoked by the application layer to stop the QF application and return control to the OS/Kernel. </p>
<dl class="section user"><dt>Description</dt><dd>This function stops the QF application. After calling this function, QF attempts to gracefully stop the application. This graceful shutdown might take some time to complete. The typical use of this function is for terminating the QF application to return back to the operating system or for handling fatal errors that require shutting down (and possibly re-setting) the system.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>After calling <a class="el" href="qv_8c.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> the application must terminate and cannot continue. In particular, <a class="el" href="qv_8c.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> is <b>not</b> intended to be followed by a call to <a class="el" href="qv_8c.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> to "resurrect" the application.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qutest_8c_source.html#l00070">70</a> of file <a class="el" href="qutest_8c_source.html">qutest.c</a>.</p>

</div>
</div>
<a id="a189a6d2ece787717c81fbf51fd180732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189a6d2ece787717c81fbf51fd180732">&#9670;&nbsp;</a></span>QF_onStartup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onStartup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Startup QF callback. </p>
<dl class="section user"><dt>Description</dt><dd>The timeline for calling <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732" title="Startup QF callback.">QF_onStartup()</a> depends on the particular QF port. In most cases, <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732" title="Startup QF callback.">QF_onStartup()</a> is called from <a class="el" href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a>, right before starting any multitasking kernel or the background loop. </dd></dl>

</div>
</div>
<a id="a5d7e181f2e679e1fa77c1e915fbee3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7e181f2e679e1fa77c1e915fbee3e0">&#9670;&nbsp;</a></span>QF_onCleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onCleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup QF callback. </p>
<dl class="section user"><dt>Description</dt><dd><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> is called in some QF ports before QF returns to the underlying operating system or RTOS.</dd></dl>
<p>This function is strongly platform-specific and is not implemented in the QF, but either in the QF port or in the Board Support Package (BSP) for the given application. Some QF ports might not require implementing <a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> at all, because many embedded applications don't have anything to exit to.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> </dd></dl>

</div>
</div>
<a id="a1fb533f5e56964494448184a1991f8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb533f5e56964494448184a1991f8db">&#9670;&nbsp;</a></span>QF_publish_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_publish_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish event to the framework. </p>
<dl class="section user"><dt>Description</dt><dd>This function posts (using the FIFO policy) the event <em>e</em> to <b>all</b> active objects that have subscribed to the signal <em>e-&gt;sig</em>, which is called <em>multicasting</em>. The multicasting performed in this function is very efficient based on reference-counting inside the published event ("zero-copy" event multicasting). This function is designed to be callable from any part of the system, including ISRs, device drivers, and active objects.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To avoid any unexpected re-ordering of events posted into AO queues, the event multicasting is performed with scheduler <b>locked</b>. However, the scheduler is locked only up to the priority level of the highest- priority subscriber, so any AOs of even higher priority, which did not subscribe to this event are <em>not</em> affected.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>this function should be called only via the macro <a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782" title="Invoke the event publishing facility QF_publish_().">QF_PUBLISH()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the published signal must be within the configured range</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__ps_8c_source.html#l00121">121</a> of file <a class="el" href="qf__ps_8c_source.html">qf_ps.c</a>.</p>

</div>
</div>
<a id="a8cf676a0ed64ab7ed8a8151f1f2e7c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf676a0ed64ab7ed8a8151f1f2e7c82">&#9670;&nbsp;</a></span>QF_tickX_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_tickX_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>tickRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes all armed time events at every clock tick. </p>
<dl class="section user"><dt>Description</dt><dd>This function must be called periodically from a time-tick ISR or from a task so that QF can manage the timeout events assigned to the given system clock tick rate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate</td><td>system clock tick rate serviced in this call [1..15].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function should be called only via the macro <a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e" title="Invoke the system clock tick processing QF_tickX_().">QF_TICK_X()</a></dd>
<dd>
the calls to <a class="el" href="qf__time_8c.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a> with different <code>tickRate</code> parameter can preempt each other. For example, higher clock tick rates might be serviced from interrupts while others from tasks (active objects).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#struct_q_time_evt" title="Time Event structure.">QTimeEvt</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00079">79</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a691ef631f5557b516f13f32ca9eb1338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691ef631f5557b516f13f32ca9eb1338">&#9670;&nbsp;</a></span>QF_noTimeEvtsActiveX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QF_noTimeEvtsActiveX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>tickRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 'true' if there are no armed time events at a given tick rate. </p>
<dl class="section user"><dt>Description</dt><dd>Find out if any time events are armed at the given clock tick rate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate</td><td>system clock tick rate to find out about.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if no time events are armed at the given tick rate and 'false' otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called in critical section. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00206">206</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a438fc360095cdafd2b4ba7f5d65bc9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438fc360095cdafd2b4ba7f5d65bc9b0">&#9670;&nbsp;</a></span>QF_add_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_add_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an active object to be managed by the framework. </p>
<dl class="section user"><dt>Description</dt><dd>This function adds a given active object to the active objects managed by the QF framework. It should not be called by the application directly, only by the QP ports.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the active object to add to the framework.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The priority of the active object <code>a</code> should be set before calling this function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__act_8c.html#a35b0d9d2c9ad2546fea14975bc1a1328" title="Remove the active object from the framework.">QF_remove_()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the priority of the active object must not be zero and cannot exceed the maximum <a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>. Also, the priority of the active object must not be already in use. QF requires each active object to have a <b>unique</b> priority.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__act_8c_source.html#l00070">70</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

</div>
</div>
<a id="a35b0d9d2c9ad2546fea14975bc1a1328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b0d9d2c9ad2546fea14975bc1a1328">&#9670;&nbsp;</a></span>QF_remove_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_remove_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#struct_q_active">QActive</a> *const&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the active object from the framework. </p>
<dl class="section user"><dt>Description</dt><dd>This function removes a given active object from the active objects managed by the QF framework. It should not be called by the application directly, only by the QP ports.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the active object to remove from the framework.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The active object that is removed from the framework can no longer participate in the publish-subscribe event exchange.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__act_8c.html#a438fc360095cdafd2b4ba7f5d65bc9b0" title="Register an active object to be managed by the framework.">QF_add_()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the priority of the active object must not be zero and cannot exceed the maximum <a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>. Also, the priority of the active object must be already registered with the framework.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__act_8c_source.html#l00103">103</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

</div>
</div>
<a id="ae52d81b1bd2cab6523fbe13cb5d79190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52d81b1bd2cab6523fbe13cb5d79190">&#9670;&nbsp;</a></span>QF_getPoolMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> QF_getPoolMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the minimum of free entries of the given event pool. </p>
<dl class="section user"><dt>Description</dt><dd>This function obtains the minimum number of free blocks in the given event pool since this pool has been initialized by a call to <a class="el" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poolId</td><td>event pool ID in the range 1..QF_maxPool_, where QF_maxPool_ is the number of event pools initialized with the function <a class="el" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of unused blocks in the given event pool. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the poolId must be in range</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__mem_8c_source.html#l00290">290</a> of file <a class="el" href="qf__mem_8c_source.html">qf_mem.c</a>.</p>

</div>
</div>
<a id="a29692c0dcab731199b5beb5847484ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29692c0dcab731199b5beb5847484ab7">&#9670;&nbsp;</a></span>QF_getQueueMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> QF_getQueueMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the minimum of free entries of the given event queue. </p>
<dl class="section user"><dt>Description</dt><dd>Queries the minimum of free ever present in the given event queue of an active object with priority <code>prio</code>, since the active object was started.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is available only when the native QF event queue implementation is used. Requesting the queue minimum of an unused priority level raises an assertion in the QF. (A priority level becomes used in QF after the call to the <a class="el" href="qf_8h.html#a438fc360095cdafd2b4ba7f5d65bc9b0" title="Register an active object to be managed by the framework.">QF_add_()</a> function.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>Priority of the active object, whose queue is queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum of free ever present in the given event queue of an active object with priority <code>prio</code>, since the active object was started. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__actq_8c_source.html#l00398">398</a> of file <a class="el" href="qf__actq_8c_source.html">qf_actq.c</a>.</p>

</div>
</div>
<a id="a1c49ff8c7895ca20958de54583a4e9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c49ff8c7895ca20958de54583a4e9cd">&#9670;&nbsp;</a></span>QF_newX_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep_8h.html#struct_q_evt">QEvt</a>* QF_newX_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>evtSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal QF implementation of creating new dynamic event. </p>
<dl class="section user"><dt>Description</dt><dd>Allocates an event dynamically from one of the QF event pools.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtSize</td><td>the size (in bytes) of the event to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin</td><td>the number of un-allocated events still available in a given event pool after the allocation completes. The special value <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> means that this function will assert if allocation fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>the signal to be assigned to the allocated event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly allocated event. This pointer can be NULL only if margin!=0 and the event cannot be allocated with the specified margin still available in the given pool.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The internal QF function <a class="el" href="qf__dyn_8c.html#a1c49ff8c7895ca20958de54583a4e9cd" title="Internal QF implementation of creating new dynamic event.">QF_newX_()</a> raises an assertion when the <code>margin</code> parameter is <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> and allocation of the event turns out to be impossible due to event pool depletion, or incorrect (too big) size of the requested event.</dd>
<dd>
The application code should not call this function directly. The only allowed use is thorough the macros <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a> or <a class="el" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436" title="Allocate a dynamic event (non-asserting version).">Q_NEW_X()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00164">164</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a770a14292ba710e2843901dca56cb4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770a14292ba710e2843901dca56cb4bb">&#9670;&nbsp;</a></span>QF_newRef_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="qep_8h.html#struct_q_evt">QEvt</a>* QF_newRef_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>evtRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal QF implementation of creating new event reference. </p>
<dl class="section user"><dt>Description</dt><dd>Creates and returns a new reference to the current event e</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the current event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtRef</td><td>the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created reference to the event <code>e</code></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. The only allowed use is thorough the macro <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the event must be dynamic and the provided event reference must not be already in use</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00286">286</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="aebb373ddc448c4198e4247b6c6ff3e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb373ddc448c4198e4247b6c6ff3e69">&#9670;&nbsp;</a></span>QF_deleteRef_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_deleteRef_ </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>evtRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal QF implementation of deleting event reference. </p>
<dl class="section user"><dt>Description</dt><dd>Deletes an existing reference to the event e</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtRef</td><td>the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. The only allowed use is thorough the macro <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00320">320</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a7aa4e9d39b8af089405cb829e2cc5a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa4e9d39b8af089405cb829e2cc5a24">&#9670;&nbsp;</a></span>QF_gc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_gc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep_8h.html#struct_q_evt">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycle a dynamic event. </p>
<dl class="section user"><dt>Description</dt><dd>This function implements a simple garbage collector for the dynamic events. Only dynamic events are candidates for recycling. (A dynamic event is one that is allocated from an event pool, which is determined as non-zero e-&gt;poolId_ attribute.) Next, the function decrements the reference counter of the event (e-&gt;refCtr_), and recycles the event only if the counter drops to zero (meaning that no more references are outstanding for this event). The dynamic event is recycled by returning it to the pool from which it was originally allocated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the event to recycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>QF invokes the garbage collector at all appropriate contexts, when an event can become garbage (automatic garbage collection), so the application code should have no need to call <a class="el" href="qf__dyn_8c.html#a7aa4e9d39b8af089405cb829e2cc5a24" title="Recycle a dynamic event.">QF_gc()</a> directly. The <a class="el" href="qf__dyn_8c.html#a7aa4e9d39b8af089405cb829e2cc5a24" title="Recycle a dynamic event.">QF_gc()</a> function is exposed only for special cases when your application sends dynamic events to the "raw" thread-safe queues (see <a class="el" href="qequeue_8h.html#struct_q_e_queue" title="Native QF Event Queue.">QEQueue</a>). Such queues are processed outside of QF and the automatic garbage collection is <b>NOT</b> performed for these events. In this case you need to call <a class="el" href="qf__dyn_8c.html#a7aa4e9d39b8af089405cb829e2cc5a24" title="Recycle a dynamic event.">QF_gc()</a> explicitly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00230">230</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a1e5f5f3c33ce2706283cbe8179a9a2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5f5f3c33ce2706283cbe8179a9a2c5">&#9670;&nbsp;</a></span>QF_bzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_bzero </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a specified region of memory to zero. </p>
<dl class="section user"><dt>Description</dt><dd>Clears a memory buffer by writing zeros byte-by-byte.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>pointer to the beginning of a memory buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the memory buffer to clear (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The main application of this function is clearing the internal QF variables upon startup. This is done to avoid problems with non-standard startup code provided with some compilers and toolsets (e.g., TI DSPs or Microchip MPLAB), which does not zero the uninitialized variables, as required by the ANSI C standard. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__act_8c_source.html#l00144">144</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

</div>
</div>
<a id="a199fd259df25c25b190a8a61c3ec3b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199fd259df25c25b190a8a61c3ec3b90">&#9670;&nbsp;</a></span>QTicker_ctor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QTicker_ctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#ad83956ec689cb4ccf4732a91c7821894">QTicker</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>tickRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the QTicker Active Object class. </p>
<p>Constructor of the QTicker Active Object class. </p>

<p class="definition">Definition at line <a class="el" href="qf__actq_8c_source.html#l00439">439</a> of file <a class="el" href="qf__actq_8c_source.html">qf_actq.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6ece34fc555ade0a6a10a259a6463401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ece34fc555ade0a6a10a259a6463401">&#9670;&nbsp;</a></span>QF_active_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qf_8h.html#struct_q_active">QActive</a>* QF_active_[<a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a>+1U]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>array of registered active objects </p>
<dl class="section note"><dt>Note</dt><dd>Not to be used by Clients directly, only in ports of QF </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__act_8c_source.html#l00054">54</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aqep_8h_html_ac8ae4728dfab5ce26a907fc624f6e104"><div class="ttname"><a href="qep_8h.html#ac8ae4728dfab5ce26a907fc624f6e104">QHsm_top</a></div><div class="ttdeci">QState QHsm_top(void const *const me, QEvt const *const e)</div><div class="ttdoc">the top-state.</div><div class="ttdef"><b>Definition:</b> <a href="qep__hsm_8c_source.html#l00235">qep_hsm.c:235</a></div></div>
<div class="ttc" id="aqpc_8h_html"><div class="ttname"><a href="qpc_8h.html">qpc.h</a></div><div class="ttdoc">QP/C public interface including backwards-compatibility layer.</div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_aba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdoc">exact-width 8-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00029">16bit/stdint.h:29</a></div></div>
<div class="ttc" id="aqassert_8h_html_a27042866331f49c9e9ff4f3ef459eaaf"><div class="ttname"><a href="qassert_8h.html#a27042866331f49c9e9ff4f3ef459eaaf">Q_DEFINE_THIS_FILE</a></div><div class="ttdeci">#define Q_DEFINE_THIS_FILE</div><div class="ttdoc">Define the file name (with __FILE__) for assertions in this file.</div><div class="ttdef"><b>Definition:</b> <a href="qassert_8h_source.html#l00104">qassert.h:104</a></div></div>
<div class="ttc" id="aqf_8h_html_a1c4fc5636c2bc2e9d47e958aac05b8e1"><div class="ttname"><a href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a></div><div class="ttdeci">void QF_poolInit(void *const poolSto, uint_fast32_t const poolSize, uint_fast16_t const evtSize)</div><div class="ttdoc">Event pool initialization for dynamic allocation of events.</div><div class="ttdef"><b>Definition:</b> <a href="qf__dyn_8c_source.html#l00113">qf_dyn.c:113</a></div></div>
<div class="ttc" id="aqf_8h_html_a292a76f05e6800a383c7615b4c88cd0e"><div class="ttname"><a href="qf_8h.html#a292a76f05e6800a383c7615b4c88cd0e">QActive::super</a></div><div class="ttdeci">QHsm super</div><div class="ttdoc">inherits QHsm</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00115">qf.h:115</a></div></div>
<div class="ttc" id="astruct_q_active_vtable_html"><div class="ttname"><a href="struct_q_active_vtable.html">QActiveVtable</a></div><div class="ttdoc">Virtual table for the QActive class.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00170">qf.h:170</a></div></div>
<div class="ttc" id="aqf_8h_html_aa52b4d3c43a262022392c6e11be06436"><div class="ttname"><a href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a></div><div class="ttdeci">#define Q_NEW_X(e_, evtT_, margin_, sig_)</div><div class="ttdoc">Allocate a dynamic event (non-asserting version).</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00736">qf.h:736</a></div></div>
<div class="ttc" id="aqf_8h_html_a766856b24aa5163b7ca90bc3432f1e3e"><div class="ttname"><a href="qf_8h.html#a766856b24aa5163b7ca90bc3432f1e3e">QACTIVE_POST_X</a></div><div class="ttdeci">#define QACTIVE_POST_X(me_, e_, margin_, sender_)</div><div class="ttdoc">Polymorphically posts an event to an active object (FIFO) without delivery guarantee.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00285">qf.h:285</a></div></div>
<div class="ttc" id="aqf_8h_html_a9d4bc166d6d02d43fe5621cdd29c5013"><div class="ttname"><a href="qf_8h.html#a9d4bc166d6d02d43fe5621cdd29c5013">QTimeEvt_disarm</a></div><div class="ttdeci">bool QTimeEvt_disarm(QTimeEvt *const me)</div><div class="ttdoc">Disarm a time event.</div><div class="ttdef"><b>Definition:</b> <a href="qf__time_8c_source.html#l00372">qf_time.c:372</a></div></div>
<div class="ttc" id="aqep_8h_html_struct_q_evt"><div class="ttname"><a href="qep_8h.html#struct_q_evt">QEvt</a></div><div class="ttdoc">Event structure.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00151">qep.h:151</a></div></div>
<div class="ttc" id="aqf_8h_html_a779a1bc9482e2d489dc87751cd100fdb"><div class="ttname"><a href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a></div><div class="ttdeci">int_t QF_run(void)</div><div class="ttdoc">Transfers control to QF to run the application.</div><div class="ttdef"><b>Definition:</b> <a href="qutest_8c_source.html#l00074">qutest.c:74</a></div></div>
<div class="ttc" id="aqep_8h_html_a54b2da5e70ef983cfa7ca74deac237a3"><div class="ttname"><a href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a></div><div class="ttdeci">#define Q_HANDLED()</div><div class="ttdoc">Macro to call in a state-handler when it handles an event.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00481">qep.h:481</a></div></div>
<div class="ttc" id="aqassert_8h_html_ad58d2c6dc25f8f0f764eb69faa79eee2"><div class="ttname"><a href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a></div><div class="ttdeci">#define Q_DIM(array_)</div><div class="ttdoc">Helper macro to calculate static dimension of a 1-dim array_.</div><div class="ttdef"><b>Definition:</b> <a href="qassert_8h_source.html#l00337">qassert.h:337</a></div></div>
<div class="ttc" id="aqf_8h_html_a3a20b07a97300a74383cd863cbfd6bc6"><div class="ttname"><a href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">QF_psInit</a></div><div class="ttdeci">void QF_psInit(QSubscrList *const subscrSto, enum_t const maxSignal)</div><div class="ttdoc">Publish-subscribe initialization.</div><div class="ttdef"><b>Definition:</b> <a href="qf__ps_8c_source.html#l00087">qf_ps.c:87</a></div></div>
<div class="ttc" id="aqf_8h_html_a3123ef03f5d66d866da12c736ac574b0"><div class="ttname"><a href="qf_8h.html#a3123ef03f5d66d866da12c736ac574b0">QACTIVE_START</a></div><div class="ttdeci">#define QACTIVE_START(me_, prio_, qSto_, qLen_, stkSto_, stkLen_, par_)</div><div class="ttdoc">Polymorphically start an active object.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00215">qf.h:215</a></div></div>
<div class="ttc" id="aqep_8h_html_adf764cbdea00d65edcd07bb9953ad2b7ac286909dd59290d1076b51d4cfdfaefe"><div class="ttname"><a href="qep_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a></div><div class="ttdeci">@ Q_ENTRY_SIG</div><div class="ttdoc">signal for coding entry actions</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00617">qep.h:617</a></div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_ad0906fbe05a45fbdb000c58fe8929e70"><div class="ttname"><a href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a></div><div class="ttdeci">unsigned int uint_fast8_t</div><div class="ttdoc">fast at-least 8-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00036">16bit/stdint.h:36</a></div></div>
<div class="ttc" id="aqf_8h_html_a3c1957439cb1ecff92be7b7401bf3159"><div class="ttname"><a href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a></div><div class="ttdeci">#define QF_NO_MARGIN</div><div class="ttdoc">special value of margin that causes asserting failure in case event allocation or event posting fails</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00637">qf.h:637</a></div></div>
<div class="ttc" id="aqf_8h_html_adac7eccb860d910c4e446d3143798bba"><div class="ttname"><a href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a></div><div class="ttdeci">void QF_init(void)</div><div class="ttdoc">QF initialization.</div><div class="ttdef"><b>Definition:</b> <a href="qutest_8c_source.html#l00056">qutest.c:56</a></div></div>
<div class="ttc" id="aqep_8h_html_ad141f4e9efcba4613f82a8b2c76663ad"><div class="ttname"><a href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a></div><div class="ttdeci">uint_fast8_t QState</div><div class="ttdoc">typedef of the return type from a state/action-handler function.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00202">qep.h:202</a></div></div>
<div class="ttc" id="aqf_8h_html_a1c49ff8c7895ca20958de54583a4e9cd"><div class="ttname"><a href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">QF_newX_</a></div><div class="ttdeci">QEvt * QF_newX_(uint_fast16_t const evtSize, uint_fast16_t const margin, enum_t const sig)</div><div class="ttdoc">Internal QF implementation of creating new dynamic event.</div><div class="ttdef"><b>Definition:</b> <a href="qf__dyn_8c_source.html#l00164">qf_dyn.c:164</a></div></div>
<div class="ttc" id="aqs_8h_html_a034206ff7f20a4e6426a5f554434643b"><div class="ttname"><a href="qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a></div><div class="ttdeci">#define QS_OBJ_DICTIONARY(obj_)</div><div class="ttdoc">Output object dictionary record.</div><div class="ttdef"><b>Definition:</b> <a href="qs_8h_source.html#l00892">qs.h:892</a></div></div>
<div class="ttc" id="aqep_8h_html_a8f06cd90ba5060780fc61a4810e3eb50"><div class="ttname"><a href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50">Q_TRAN</a></div><div class="ttdeci">#define Q_TRAN(target_)</div><div class="ttdoc">Macro to call in a state-handler when it executes a regular or and initial transition.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00457">qep.h:457</a></div></div>
<div class="ttc" id="aqep_8h_html_adf764cbdea00d65edcd07bb9953ad2b7ab54538c21a62926a2f1d63d8fd45bf5c"><div class="ttname"><a href="qep_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ab54538c21a62926a2f1d63d8fd45bf5c">Q_EXIT_SIG</a></div><div class="ttdeci">@ Q_EXIT_SIG</div><div class="ttdoc">signal for coding exit actions</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00618">qep.h:618</a></div></div>
<div class="ttc" id="aqf_8h_html_abd823f3a9e8b3206a3460a108d5fa3e3"><div class="ttname"><a href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a></div><div class="ttdeci">#define Q_NEW(evtT_, sig_)</div><div class="ttdoc">Allocate a dynamic event.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00706">qf.h:706</a></div></div>
<div class="ttc" id="aqep_8h_html_ad8abd2f7098c41ec464343d9d8f1eadc"><div class="ttname"><a href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc">Q_SUPER</a></div><div class="ttdeci">#define Q_SUPER(super_)</div><div class="ttdoc">Macro to call in a state-handler when it designates the superstate of a given state.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00475">qep.h:475</a></div></div>
<div class="ttc" id="aqf_8h_html_ae2510a52f1185e2561fa78323983c04d"><div class="ttname"><a href="qf_8h.html#ae2510a52f1185e2561fa78323983c04d">QActive_subscribe</a></div><div class="ttdeci">void QActive_subscribe(QActive const *const me, enum_t const sig)</div><div class="ttdoc">Subscribes for delivery of signal sig to the active object me.</div><div class="ttdef"><b>Definition:</b> <a href="qf__ps_8c_source.html#l00206">qf_ps.c:206</a></div></div>
<div class="ttc" id="aqk_2qf__port_8h_html_ad2d11956704ad838c9c954368d3d37d5"><div class="ttname"><a href="qk_2qf__port_8h.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a></div><div class="ttdeci">#define QF_INT_ENABLE()</div><div class="ttdoc">Define the interrupt enabling policy.</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8h_source.html#l00209">qk/qf_port.h:209</a></div></div>
<div class="ttc" id="aqf_8h_html_struct_q_time_evt"><div class="ttname"><a href="qf_8h.html#struct_q_time_evt">QTimeEvt</a></div><div class="ttdoc">Time Event structure.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00442">qf.h:442</a></div></div>
<div class="ttc" id="aqf_8h_html_a9bbcb00315fb8bb8641003b2b2d07ce4"><div class="ttname"><a href="qf_8h.html#a9bbcb00315fb8bb8641003b2b2d07ce4">QTimeEvt_armX</a></div><div class="ttdeci">void QTimeEvt_armX(QTimeEvt *const me, QTimeEvtCtr const nTicks, QTimeEvtCtr const interval)</div><div class="ttdoc">Arm a time event (one shot or periodic) for direct event posting.</div><div class="ttdef"><b>Definition:</b> <a href="qf__time_8c_source.html#l00298">qf_time.c:298</a></div></div>
<div class="ttc" id="aqk_2qf__port_8h_html_a88df5203e3a9716327b58923f5aaac80"><div class="ttname"><a href="qk_2qf__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a></div><div class="ttdeci">#define QF_INT_DISABLE()</div><div class="ttdoc">Define the interrupt disabling policy.</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8h_source.html#l00198">qk/qf_port.h:198</a></div></div>
<div class="ttc" id="aqf_8h_html_a1f1970e16f4d010b5e5b2fd046aac41e"><div class="ttname"><a href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a></div><div class="ttdeci">#define QF_TICK_X(tickRate_, sender_)</div><div class="ttdoc">Invoke the system clock tick processing QF_tickX_().</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00625">qf.h:625</a></div></div>
<div class="ttc" id="aqf_8h_html_afd57334f2a1664a168b0702a106e0782"><div class="ttname"><a href="qf_8h.html#afd57334f2a1664a168b0702a106e0782">QF_PUBLISH</a></div><div class="ttdeci">#define QF_PUBLISH(e_, sender_)</div><div class="ttdoc">Invoke the event publishing facility QF_publish_().</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00582">qf.h:582</a></div></div>
<div class="ttc" id="aqmpool_8h_html_ab0fe475154021674f904c52e61e78841"><div class="ttname"><a href="qmpool_8h.html#ab0fe475154021674f904c52e61e78841">QF_MPOOL_EL</a></div><div class="ttdeci">#define QF_MPOOL_EL(evType_)</div><div class="ttdoc">Memory pool element to allocate correctly aligned storage for QMPool class.</div><div class="ttdef"><b>Definition:</b> <a href="qmpool_8h_source.html#l00165">qmpool.h:165</a></div></div>
<div class="ttc" id="aqpset_8h_html_struct_q_p_set"><div class="ttname"><a href="qpset_8h.html#struct_q_p_set">QPSet</a></div><div class="ttdoc">Priority Set of up to 32 elements.</div><div class="ttdef"><b>Definition:</b> <a href="qpset_8h_source.html#l00068">qpset.h:68</a></div></div>
<div class="ttc" id="aqf_8h_html_ab7c56990d949c8708e3fe2b737f2e65c"><div class="ttname"><a href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c">QACTIVE_POST</a></div><div class="ttdeci">#define QACTIVE_POST(me_, e_, sender_)</div><div class="ttdoc">Polymorphically posts an event to an active object (FIFO) with delivery guarantee.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00247">qf.h:247</a></div></div>
<div class="ttc" id="aqep_8h_html_a20b1ceebb91aea39fcbc633aeae6cd3f"><div class="ttname"><a href="qep_8h.html#a20b1ceebb91aea39fcbc633aeae6cd3f">QEvt::sig</a></div><div class="ttdeci">QSignal sig</div><div class="ttdoc">signal of the event instance</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00152">qep.h:152</a></div></div>
<div class="ttc" id="aqf_8h_html_struct_q_active"><div class="ttname"><a href="qf_8h.html#struct_q_active">QActive</a></div><div class="ttdoc">Active Object (based on QHsm implementation)</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00114">qf.h:114</a></div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_a226d967fb6d06433caf43f20dc876aae"><div class="ttname"><a href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a></div><div class="ttdeci">unsigned int uint_fast16_t</div><div class="ttdoc">fast at-least 16-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00038">16bit/stdint.h:38</a></div></div>
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C 6.8.0</b>
    </li>
  </ul>
</div>
</body>
</html>
