//.$file${.::calc1_sub.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: calc1_sub.qm
// File:  ${.::calc1_sub.cpp}
//
// This code has been generated by QM 4.6.0 <www.state-machine.com/qm/>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #   : QPCPP-EVAL
// Issued to   : Institution or an individual evaluating the QP/C++ framework
// Framework(s): qpcpp
// Support ends: 2020-12-31
// Product(s)  :
// This license is available only for evaluation purposes and
// the generated code is still licensed under the terms of GPL.
// Please submit request for extension of the evaluaion period at:
// <www.state-machine.com/licensing/#RequestForm>
//
//.$endhead${.::calc1_sub.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"     // QP/C++ API
#include "bsp.hpp"       // board support package
#include "calc1_sub.hpp" // application

Q_DEFINE_THIS_FILE

#define KEY_NULL    '\0'
#define KEY_PLUS    '+'
#define KEY_MINUS   '-'
#define KEY_MULT    '*'
#define KEY_DIVIDE  '/'

//.$declare${SMs::Calc} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${SMs::Calc} ..............................................................
class Calc : public QP::QMsm {
public:
    static Calc inst;

private:
    double m_op1;
    double m_op2;
    uint8_t m_oper1;
    uint8_t m_oper2;

public:
    Calc();

    // guard function to evaluate the current expression
    // taking into account the precedence of operands.
    // return: true if evaluation successfull
    // false when error encountered
    bool eval(double op, uint8_t oper);

protected:
    struct SM_operand { // submachine "operand"
        QP::QMState super;
        QP::QActionHandler const CE; // exit-point segment
    } const *sub_operand;

    static QP::QState initial(Calc * const me, QP::QEvt const * const e);
    static QP::QState on  (Calc * const me, QP::QEvt const * const e);
    static QP::QState on_e(Calc * const me);
    static QP::QState on_x(Calc * const me);
    static QP::QState on_i(Calc * const me);
    static QP::QMState const on_s;
    static QP::QState ready  (Calc * const me, QP::QEvt const * const e);
    static QP::QState ready_e(Calc * const me);
    static QP::QState ready_x(Calc * const me);
    static QP::QState ready_i(Calc * const me);
    static QP::QMState const ready_s;
    static QP::QState result  (Calc * const me, QP::QEvt const * const e);
    static QP::QState result_e(Calc * const me);
    static QP::QState result_x(Calc * const me);
    static QP::QMState const result_s;
    static QP::QState begin  (Calc * const me, QP::QEvt const * const e);
    static QP::QState begin_e(Calc * const me);
    static QP::QState begin_x(Calc * const me);
    static QP::QMState const begin_s;
    static QP::QState operand1  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand1_e(Calc * const me);
    static QP::QState operand1_CE(Calc * const me);
    static SM_operand const operand1_s;
    static QP::QState opEntered  (Calc * const me, QP::QEvt const * const e);
    static QP::QState opEntered_e(Calc * const me);
    static QP::QState opEntered_x(Calc * const me);
    static QP::QMState const opEntered_s;
    static QP::QState operand2  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand2_e(Calc * const me);
    static QP::QState operand2_CE(Calc * const me);
    static SM_operand const operand2_s;
    static QP::QState error  (Calc * const me, QP::QEvt const * const e);
    static QP::QState error_e(Calc * const me);
    static QP::QState error_x(Calc * const me);
    static QP::QMState const error_s;
    static QP::QState final  (Calc * const me, QP::QEvt const * const e);
    static QP::QState final_e(Calc * const me);
    static QP::QMState const final_s;

    // submachine "operand"
    static QP::QState operand  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand_e(Calc * const me);
    static QP::QState operand_x(Calc * const me);
    static QP::QState operand_i(Calc * const me);
    static QP::QMState const operand_s;
    static QP::QState operand_zero_ep(Calc * const me);
    static QP::QState operand_intgr_ep(Calc * const me);
    static QP::QState operand_frac_ep(Calc * const me);
    static QP::QState operand_neg_ep(Calc * const me);
    static QP::QState operand_zero  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand_zero_e(Calc * const me);
    static QP::QState operand_zero_x(Calc * const me);
    static QP::QMState const operand_zero_s;
    static QP::QState operand_intgr  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand_intgr_e(Calc * const me);
    static QP::QState operand_intgr_x(Calc * const me);
    static QP::QMState const operand_intgr_s;
    static QP::QState operand_frac  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand_frac_e(Calc * const me);
    static QP::QState operand_frac_x(Calc * const me);
    static QP::QMState const operand_frac_s;
    static QP::QState operand_neg  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand_neg_e(Calc * const me);
    static QP::QState operand_neg_x(Calc * const me);
    static QP::QMState const operand_neg_s;
};
//.$enddecl${SMs::Calc} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//. Check for the minimum required QP version
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 6.5.0 or higher required
#endif
//.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$define${SMs::the_calc} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${SMs::the_calc} ..........................................................
QP::QHsm * const the_calc = &Calc::inst;
//.$enddef${SMs::the_calc} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$define${SMs::Calc} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${SMs::Calc} ..............................................................
Calc Calc::inst;
//.${SMs::Calc::Calc} ........................................................
Calc::Calc()
  : QMsm(Q_STATE_CAST(&initial))
{}


// guard function to evaluate the current expression
// taking into account the precedence of operands.
// return: true if evaluation successfull
// false when error encountered
//.${SMs::Calc::eval} ........................................................
bool Calc::eval(double op, uint8_t oper) {
    double result;
    if ((oper == KEY_NULL) || (oper == KEY_PLUS) || (oper == KEY_MINUS)) {
        switch (m_oper2) {
            case KEY_MULT: {
                m_op2 *= op;
                break;
            }
            case KEY_DIVIDE: {
                if ((-1e-30 < op) && (op < 1e-30)) {
                    BSP_display_error(" Error 0 "); // divide by zero
                    return false;
                }
                m_op2 /= op;
                break;
             }
             default: { /* no op2 yet */
                m_op2 = op;
                m_oper2 = oper;
                break;
             }
        }
        switch (m_oper1) {
            case KEY_PLUS: {
                m_op1 += m_op2;
                break;
            }
            case KEY_MINUS: {
                m_op1 -= m_op2;
                break;
            }
            case KEY_MULT: {
                m_op1 *= m_op2;
                break;
            }
            case KEY_DIVIDE: {
                if ((-1e-30 < m_op2) && (m_op2 < 1e-30)) {
                    BSP_display_error(" Error 0 "); // divide by zero
                    return false;
                }
                m_op1 /= m_op2;
                break;
            }
            default: {
                Q_ERROR();
                break;
            }
        }
        m_oper1 = oper;
        m_oper2 = KEY_NULL;
        result = m_op1;
    }
    else { // (oper == KEY_MULT) || (oper == KEY_DIV)
        switch (m_oper2) {
            case KEY_MULT: {
                m_op2 *= op;
                break;
            }
            case KEY_DIVIDE: {
                if ((-1e-30 < op) && (op < 1e-30)) {
                    BSP_display_error(" Error 0 "); // divide by zero
                    return false;
                }
                m_op2 /= op;
                break;
            }
            default: { // oper2 not provided yet
                m_op2 = op;
                break;
            }
        }
        m_oper2 = oper;
        result = m_op2;
    }

    if ((result < -99999999.0) || (99999999.0 < result)) {
        BSP_display_error(" Error 1 "); // out of range
        return false;
    }
    if ((-0.0000001 < result) && (result < 0.0000001)) {
        result = 0.0;
    }
    BSP_display(result);

    return true;
}

//.${SMs::Calc::SM} ..........................................................
QP::QState Calc::initial(Calc * const me, QP::QEvt const * const e) {
    //.${SMs::Calc::SM::initial}
    BSP_clear();
    (void)e; // unused parameter

    QS_FUN_DICTIONARY(&on);
    QS_FUN_DICTIONARY(&ready);
    QS_FUN_DICTIONARY(&result);
    QS_FUN_DICTIONARY(&begin);
    QS_FUN_DICTIONARY(&operand1);
    QS_FUN_DICTIONARY(&opEntered);
    QS_FUN_DICTIONARY(&operand2);
    QS_FUN_DICTIONARY(&error);
    QS_FUN_DICTIONARY(&final);
    QS_FUN_DICTIONARY(&operand_zero);
    QS_FUN_DICTIONARY(&operand_intgr);
    QS_FUN_DICTIONARY(&operand_frac);
    QS_FUN_DICTIONARY(&operand_neg);
    QS_FUN_DICTIONARY(&operand);

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // tran-action table
        &on_s, // target state
        {
            Q_ACTION_CAST(&on_e), // entry
            Q_ACTION_CAST(&on_i), // initial tran.
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_INIT(&tatbl_);
}
//.${SMs::Calc::SM::on} ......................................................
QP::QMState const Calc::on_s = {
    QM_STATE_NULL, // superstate (top)
    Q_STATE_CAST(&Calc::on),
    Q_ACTION_CAST(&Calc::on_e),
    Q_ACTION_CAST(&Calc::on_x),
    Q_ACTION_CAST(&Calc::on_i)
};
//.${SMs::Calc::SM::on}
QP::QState Calc::on_e(Calc * const me) {
    BSP_message("on-ENTRY;");
    (void)me; // unused parameter
    return QM_ENTRY(&on_s);
}
//.${SMs::Calc::SM::on}
QP::QState Calc::on_x(Calc * const me) {
    BSP_message("on-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&on_s);
}
//.${SMs::Calc::SM::on::initial}
QP::QState Calc::on_i(Calc * const me) {
    //.${SMs::Calc::SM::on::initial}
    BSP_message("on-INIT;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // tran-action table
        &ready_s, // target state
        {
            Q_ACTION_CAST(&ready_e), // entry
            Q_ACTION_CAST(&ready_i), // initial tran.
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_INIT(&tatbl_);
}
//.${SMs::Calc::SM::on}
QP::QState Calc::on(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::on::C}
        case C_SIG: {
            BSP_clear();

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // tran-action table
                &on_s, // target state
                {
                    Q_ACTION_CAST(&on_x), // exit
                    Q_ACTION_CAST(&on_e), // entry
                    Q_ACTION_CAST(&on_i), // initial tran.
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::on::OFF}
        case OFF_SIG: {

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &final_s, // target state
                {
                    Q_ACTION_CAST(&on_x), // exit
                    Q_ACTION_CAST(&final_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    return status_;
}
//.${SMs::Calc::SM::on::ready} ...............................................
QP::QMState const Calc::ready_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&Calc::ready),
    Q_ACTION_CAST(&Calc::ready_e),
    Q_ACTION_CAST(&Calc::ready_x),
    Q_ACTION_CAST(&Calc::ready_i)
};
//.${SMs::Calc::SM::on::ready}
QP::QState Calc::ready_e(Calc * const me) {
    BSP_message("ready-ENTRY;");
    me->m_oper2 = KEY_NULL;
    return QM_ENTRY(&ready_s);
}
//.${SMs::Calc::SM::on::ready}
QP::QState Calc::ready_x(Calc * const me) {
    BSP_message("ready-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&ready_s);
}
//.${SMs::Calc::SM::on::ready::initial}
QP::QState Calc::ready_i(Calc * const me) {
    //.${SMs::Calc::SM::on::ready::initial}
    BSP_message("ready-INIT;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // tran-action table
        &begin_s, // target state
        {
            Q_ACTION_CAST(&begin_e), // entry
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_INIT(&tatbl_);
}
//.${SMs::Calc::SM::on::ready}
QP::QState Calc::ready(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::on::ready::DIGIT_0}
        case DIGIT_0_SIG: {
            BSP_clear();

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // tran-action table
                &operand_s, // target submachine
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&operand_zero_ep), // EP
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN_EP(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::on::ready::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            BSP_clear();
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // tran-action table
                &operand_s, // target submachine
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&operand_intgr_ep), // EP
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN_EP(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::on::ready::POINT}
        case POINT_SIG: {
            BSP_clear();
            BSP_insert((int)'0');
            BSP_insert((int)'.');

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // tran-action table
                &operand_s, // target submachine
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&operand_frac_ep), // EP
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN_EP(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::on::ready::OPER}
        case OPER_SIG: {
            me->m_op1  = BSP_get_value();
            me->m_oper1 = Q_EVT_CAST(CalcEvt)->key_code;

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &opEntered_s, // target state
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&opEntered_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    return status_;
}
//.${SMs::Calc::SM::on::ready::result} .......................................
QP::QMState const Calc::result_s = {
    &Calc::ready_s, // superstate
    Q_STATE_CAST(&Calc::result),
    Q_ACTION_CAST(&Calc::result_e),
    Q_ACTION_CAST(&Calc::result_x),
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result_e(Calc * const me) {
    BSP_message("result-ENTRY;");
    (void)me; // unused parameter
    return QM_ENTRY(&result_s);
}
//.${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result_x(Calc * const me) {
    BSP_message("result-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&result_s);
}
//.${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    (void)me; // unused parameter
    return status_;
}
//.${SMs::Calc::SM::on::ready::begin} ........................................
QP::QMState const Calc::begin_s = {
    &Calc::ready_s, // superstate
    Q_STATE_CAST(&Calc::begin),
    Q_ACTION_CAST(&Calc::begin_e),
    Q_ACTION_CAST(&Calc::begin_x),
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin_e(Calc * const me) {
    BSP_message("begin-ENTRY;");
    (void)me; // unused parameter
    return QM_ENTRY(&begin_s);
}
//.${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin_x(Calc * const me) {
    BSP_message("begin-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&begin_s);
}
//.${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::on::ready::begin::OPER}
        case OPER_SIG: {
            //.${SMs::Calc::SM::on::ready::begin::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {

                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[5];
                } const tatbl_ = { // tran-action table
                    &operand_s, // target submachine
                    {
                        Q_ACTION_CAST(&begin_x), // exit
                        Q_ACTION_CAST(&ready_x), // exit
                        Q_ACTION_CAST(&operand1_e), // entry
                        Q_ACTION_CAST(&operand_neg_ep), // EP
                        Q_ACTION_NULL // zero terminator
                    }
                };
                status_ = QM_TRAN_EP(&tatbl_);
            }
            //.${SMs::Calc::SM::on::ready::begin::OPER::[else]}
            else {
                status_ = Q_RET_HANDLED;
            }
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    (void)me; // unused parameter
    return status_;
}
//.${SMs::Calc::SM::on::operand1} ............................................
Calc::SM_operand const Calc::operand1_s = {
    {
        &Calc::on_s, // superstate
        Q_STATE_CAST(&Calc::operand1),
        Q_ACTION_CAST(&Calc::operand1_e),
        Q_ACTION_NULL, // no exit action
        Q_ACTION_NULL  // no initial tran.
    }

    ,Q_ACTION_CAST(&Calc::operand1_CE)
};
//.${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1_e(Calc * const me) {
    me->sub_operand = &Calc::operand1_s; // attach submachine
    return operand_e(me); // enter submachine
}
//.${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1_CE(Calc * const me) {
    BSP_message("operand1:XP-CE;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[4];
    } const tatbl_ = { // tran-action table
        &ready_s, // target state
        {
            Q_ACTION_CAST(&operand_x), // submachine exit
            Q_ACTION_CAST(&ready_e), // entry
            Q_ACTION_CAST(&ready_i), // initial tran.
            Q_ACTION_NULL // zero terminator
        }
    };
    (void)me; // unused parameter
    return QM_TRAN(&tatbl_);
}
//.${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::on::operand1::OPER}
        case OPER_SIG: {
            me->m_op1  = BSP_get_value();
            me->m_oper1 = Q_EVT_CAST(CalcEvt)->key_code;

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[2];
            } const tatbl_ = { // tran-action table
                &opEntered_s, // target state
                {
                    Q_ACTION_CAST(&opEntered_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::on::operand1::EQUALS}
        case EQUALS_SIG: {

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &result_s, // target state
                {
                    Q_ACTION_CAST(&ready_e), // entry
                    Q_ACTION_CAST(&result_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    return status_;
}
//.${SMs::Calc::SM::on::opEntered} ...........................................
QP::QMState const Calc::opEntered_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&Calc::opEntered),
    Q_ACTION_CAST(&Calc::opEntered_e),
    Q_ACTION_CAST(&Calc::opEntered_x),
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered_e(Calc * const me) {
    BSP_message("opEntered-ENTRY;");
    (void)me; // unused parameter
    return QM_ENTRY(&opEntered_s);
}
//.${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered_x(Calc * const me) {
    BSP_message("opEntered-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&opEntered_s);
}
//.${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::on::opEntered::DIGIT_0}
        case DIGIT_0_SIG: {
            BSP_clear();

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // tran-action table
                &operand_s, // target submachine
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&operand_zero_ep), // EP
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN_EP(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::on::opEntered::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            BSP_clear();
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // tran-action table
                &operand_s, // target submachine
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&operand_intgr_ep), // EP
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN_EP(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::on::opEntered::POINT}
        case POINT_SIG: {
            BSP_clear();
            BSP_insert((int)'0');
            BSP_insert((int)'.');

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // tran-action table
                &operand_s, // target submachine
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&operand_frac_ep), // EP
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN_EP(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::on::opEntered::OPER}
        case OPER_SIG: {
            //.${SMs::Calc::SM::on::opEntered::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {

                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[4];
                } const tatbl_ = { // tran-action table
                    &operand_s, // target submachine
                    {
                        Q_ACTION_CAST(&opEntered_x), // exit
                        Q_ACTION_CAST(&operand2_e), // entry
                        Q_ACTION_CAST(&operand_neg_ep), // EP
                        Q_ACTION_NULL // zero terminator
                    }
                };
                status_ = QM_TRAN_EP(&tatbl_);
            }
            //.${SMs::Calc::SM::on::opEntered::OPER::[else]}
            else {
                status_ = Q_RET_HANDLED;
            }
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    (void)me; // unused parameter
    return status_;
}
//.${SMs::Calc::SM::on::operand2} ............................................
Calc::SM_operand const Calc::operand2_s = {
    {
        &Calc::on_s, // superstate
        Q_STATE_CAST(&Calc::operand2),
        Q_ACTION_CAST(&Calc::operand2_e),
        Q_ACTION_NULL, // no exit action
        Q_ACTION_NULL  // no initial tran.
    }

    ,Q_ACTION_CAST(&Calc::operand2_CE)
};
//.${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2_e(Calc * const me) {
    me->sub_operand = &Calc::operand2_s; // attach submachine
    return operand_e(me); // enter submachine
}
//.${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2_CE(Calc * const me) {
    BSP_message("operand2:XP-CE;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // tran-action table
        &opEntered_s, // target state
        {
            Q_ACTION_CAST(&operand_x), // submachine exit
            Q_ACTION_CAST(&opEntered_e), // entry
            Q_ACTION_NULL // zero terminator
        }
    };
    (void)me; // unused parameter
    return QM_TRAN(&tatbl_);
}
//.${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::on::operand2::OPER}
        case OPER_SIG: {
            //.${SMs::Calc::SM::on::operand2::OPER::[eval()]}
            if (me->eval(BSP_get_value(), Q_EVT_CAST(CalcEvt)->key_code)) {

                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[2];
                } const tatbl_ = { // tran-action table
                    &opEntered_s, // target state
                    {
                        Q_ACTION_CAST(&opEntered_e), // entry
                        Q_ACTION_NULL // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            //.${SMs::Calc::SM::on::operand2::OPER::[else]}
            else {

                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[2];
                } const tatbl_ = { // tran-action table
                    &error_s, // target state
                    {
                        Q_ACTION_CAST(&error_e), // entry
                        Q_ACTION_NULL // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        //.${SMs::Calc::SM::on::operand2::EQUALS}
        case EQUALS_SIG: {
            //.${SMs::Calc::SM::on::operand2::EQUALS::[eval()]}
            if (me->eval(BSP_get_value(), KEY_NULL)) {

                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[3];
                } const tatbl_ = { // tran-action table
                    &result_s, // target state
                    {
                        Q_ACTION_CAST(&ready_e), // entry
                        Q_ACTION_CAST(&result_e), // entry
                        Q_ACTION_NULL // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            //.${SMs::Calc::SM::on::operand2::EQUALS::[else]}
            else {

                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[2];
                } const tatbl_ = { // tran-action table
                    &error_s, // target state
                    {
                        Q_ACTION_CAST(&error_e), // entry
                        Q_ACTION_NULL // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    return status_;
}
//.${SMs::Calc::SM::on::error} ...............................................
QP::QMState const Calc::error_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&Calc::error),
    Q_ACTION_CAST(&Calc::error_e),
    Q_ACTION_CAST(&Calc::error_x),
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::on::error}
QP::QState Calc::error_e(Calc * const me) {
    BSP_message("error-ENTRY;");
    (void)me; // unused parameter
    return QM_ENTRY(&error_s);
}
//.${SMs::Calc::SM::on::error}
QP::QState Calc::error_x(Calc * const me) {
    BSP_message("error-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&error_s);
}
//.${SMs::Calc::SM::on::error}
QP::QState Calc::error(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    (void)me; // unused parameter
    return status_;
}
//.${SMs::Calc::SM::final} ...................................................
QP::QMState const Calc::final_s = {
    QM_STATE_NULL, // superstate (top)
    Q_STATE_CAST(&Calc::final),
    Q_ACTION_CAST(&Calc::final_e),
    Q_ACTION_NULL, // no exit action
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::final}
QP::QState Calc::final_e(Calc * const me) {
    BSP_message("final-ENTRY;");
    BSP_exit();
    (void)me; // unused parameter
    return QM_ENTRY(&final_s);
}
//.${SMs::Calc::SM::final}
QP::QState Calc::final(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    (void)me; // unused parameter
    return status_;
}
//.${SMs::Calc::SM::operand} .................................................
//.${SMs::Calc::SM::operand}
QP::QMState const Calc::operand_s = {
    QM_STATE_NULL, // superstate unused
    Q_STATE_CAST(&Calc::operand),
    Q_ACTION_CAST(&Calc::operand_e),
    Q_ACTION_CAST(&Calc::operand_x),
    Q_ACTION_CAST(&Calc::operand_i)
};
//.${SMs::Calc::SM::operand}
QP::QState Calc::operand_e(Calc * const me) {
    BSP_message("operand-ENTRY;");
    (void)me; // unused paramter
    return QM_ENTRY(&operand_s);
}
//.${SMs::Calc::SM::operand}
QP::QState Calc::operand_x(Calc * const me) {
    BSP_message("operand-EXIT;");
    return QM_SM_EXIT(&me->sub_operand->super);
}
//.${SMs::Calc::SM::operand::initial}
QP::QState Calc::operand_i(Calc * const me) {
    //.${SMs::Calc::SM::operand::initial}
    BSP_message("operand-INIT;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // tran-action table
        &operand_zero_s, // target state
        {
            Q_ACTION_CAST(&operand_zero_e), // entry
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_INIT(&tatbl_);
}
//.${SMs::Calc::SM::operand}
QP::QState Calc::operand(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::operand::CE}
        case CE_SIG: {
            BSP_message("operand::CE;");
            BSP_clear();
            static QP::QMTranActTable const tatbl_ = { // tran-action table
                &operand_s, // target submachine
                {
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN_XP(me->sub_operand->CE, &tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER_SUB(&me->sub_operand->super);
            break;
        }
    }
    return status_;
}
//.${SMs::Calc::SM::operand::EP-zero}
QP::QState Calc::operand_zero_ep(Calc * const me) {
    BSP_message("operand::EP-zero;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // tran-action table
        &operand_zero_s, // target state
        {
            Q_ACTION_CAST(&operand_zero_e), // entry
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_EP(&tatbl_);
}
//.${SMs::Calc::SM::operand::EP-intgr}
QP::QState Calc::operand_intgr_ep(Calc * const me) {
    BSP_message("operand::EP-intgr;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // tran-action table
        &operand_intgr_s, // target state
        {
            Q_ACTION_CAST(&operand_intgr_e), // entry
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_EP(&tatbl_);
}
//.${SMs::Calc::SM::operand::EP-frac}
QP::QState Calc::operand_frac_ep(Calc * const me) {
    BSP_message("operand::EP-frac;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // tran-action table
        &operand_frac_s, // target state
        {
            Q_ACTION_CAST(&operand_frac_e), // entry
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_EP(&tatbl_);
}
//.${SMs::Calc::SM::operand::EP-neg}
QP::QState Calc::operand_neg_ep(Calc * const me) {
    BSP_message("operand::EP-neg;");

    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // tran-action table
        &operand_neg_s, // target state
        {
            Q_ACTION_CAST(&operand_neg_e), // entry
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_EP(&tatbl_);
}
//.${SMs::Calc::SM::operand::zero} ...........................................
QP::QMState const Calc::operand_zero_s = {
    &Calc::operand_s, // superstate
    Q_STATE_CAST(&Calc::operand_zero),
    Q_ACTION_CAST(&Calc::operand_zero_e),
    Q_ACTION_CAST(&Calc::operand_zero_x),
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::operand::zero}
QP::QState Calc::operand_zero_e(Calc * const me) {
    BSP_message("operand::zero-ENTRY;");
    (void)me; // unused parameter
    return QM_ENTRY(&operand_zero_s);
}
//.${SMs::Calc::SM::operand::zero}
QP::QState Calc::operand_zero_x(Calc * const me) {
    BSP_message("operand::zero-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&operand_zero_s);
}
//.${SMs::Calc::SM::operand::zero}
QP::QState Calc::operand_zero(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::operand::zero::DIGIT_0}
        case DIGIT_0_SIG: {
            ;
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${SMs::Calc::SM::operand::zero::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &operand_intgr_s, // target state
                {
                    Q_ACTION_CAST(&operand_zero_x), // exit
                    Q_ACTION_CAST(&operand_intgr_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::operand::zero::POINT}
        case POINT_SIG: {
            BSP_insert((int)'0');
            BSP_insert((int)'.');

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &operand_frac_s, // target state
                {
                    Q_ACTION_CAST(&operand_zero_x), // exit
                    Q_ACTION_CAST(&operand_frac_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    return status_;
}
//.${SMs::Calc::SM::operand::intgr} ..........................................
QP::QMState const Calc::operand_intgr_s = {
    &Calc::operand_s, // superstate
    Q_STATE_CAST(&Calc::operand_intgr),
    Q_ACTION_CAST(&Calc::operand_intgr_e),
    Q_ACTION_CAST(&Calc::operand_intgr_x),
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::operand::intgr}
QP::QState Calc::operand_intgr_e(Calc * const me) {
    BSP_message("operand::intgr-ENTRY;");
    (void)me; // unused parameter
    return QM_ENTRY(&operand_intgr_s);
}
//.${SMs::Calc::SM::operand::intgr}
QP::QState Calc::operand_intgr_x(Calc * const me) {
    BSP_message("operand::intgr-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&operand_intgr_s);
}
//.${SMs::Calc::SM::operand::intgr}
QP::QState Calc::operand_intgr(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::operand::intgr::POINT}
        case POINT_SIG: {
            BSP_insert((int)'.');

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &operand_frac_s, // target state
                {
                    Q_ACTION_CAST(&operand_intgr_x), // exit
                    Q_ACTION_CAST(&operand_frac_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::operand::intgr::DIGIT_0, DIGIT_1_9}
        case DIGIT_0_SIG: // intentionally fall through
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    (void)me; // unused parameter
    return status_;
}
//.${SMs::Calc::SM::operand::frac} ...........................................
QP::QMState const Calc::operand_frac_s = {
    &Calc::operand_s, // superstate
    Q_STATE_CAST(&Calc::operand_frac),
    Q_ACTION_CAST(&Calc::operand_frac_e),
    Q_ACTION_CAST(&Calc::operand_frac_x),
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::operand::frac}
QP::QState Calc::operand_frac_e(Calc * const me) {
    BSP_message("operand::frac-ENTRY;");
    (void)me; // unused parameter
    return QM_ENTRY(&operand_frac_s);
}
//.${SMs::Calc::SM::operand::frac}
QP::QState Calc::operand_frac_x(Calc * const me) {
    BSP_message("operand::frac-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&operand_frac_s);
}
//.${SMs::Calc::SM::operand::frac}
QP::QState Calc::operand_frac(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::operand::frac::POINT}
        case POINT_SIG: {
            ;
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${SMs::Calc::SM::operand::frac::DIGIT_0, DIGIT_1_9}
        case DIGIT_0_SIG: // intentionally fall through
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    (void)me; // unused parameter
    return status_;
}
//.${SMs::Calc::SM::operand::neg} ............................................
QP::QMState const Calc::operand_neg_s = {
    &Calc::operand_s, // superstate
    Q_STATE_CAST(&Calc::operand_neg),
    Q_ACTION_CAST(&Calc::operand_neg_e),
    Q_ACTION_CAST(&Calc::operand_neg_x),
    Q_ACTION_NULL  // no initial tran.
};
//.${SMs::Calc::SM::operand::neg}
QP::QState Calc::operand_neg_e(Calc * const me) {
    BSP_message("operand::neg-ENTRY;");
    BSP_negate();
    (void)me; // unused parameter
    return QM_ENTRY(&operand_neg_s);
}
//.${SMs::Calc::SM::operand::neg}
QP::QState Calc::operand_neg_x(Calc * const me) {
    BSP_message("operand::neg-EXIT;");
    (void)me; // unused parameter
    return QM_EXIT(&operand_neg_s);
}
//.${SMs::Calc::SM::operand::neg}
QP::QState Calc::operand_neg(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        //.${SMs::Calc::SM::operand::neg::DIGIT_0}
        case DIGIT_0_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &operand_zero_s, // target state
                {
                    Q_ACTION_CAST(&operand_neg_x), // exit
                    Q_ACTION_CAST(&operand_zero_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::operand::neg::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &operand_intgr_s, // target state
                {
                    Q_ACTION_CAST(&operand_neg_x), // exit
                    Q_ACTION_CAST(&operand_intgr_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::operand::neg::POINT}
        case POINT_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);

            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // tran-action table
                &operand_frac_s, // target state
                {
                    Q_ACTION_CAST(&operand_neg_x), // exit
                    Q_ACTION_CAST(&operand_frac_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        //.${SMs::Calc::SM::operand::neg::OPER}
        case OPER_SIG: {
            //.${SMs::Calc::SM::operand::neg::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {
                ;
                status_ = Q_RET_HANDLED;
            }
            //.${SMs::Calc::SM::operand::neg::OPER::[else]}
            else {
                status_ = Q_RET_HANDLED;
            }
            break;
        }
        default: {
            status_ = Q_RET_SUPER;
            break;
        }
    }
    (void)me; // unused parameter
    return status_;
}
//.$enddef${SMs::Calc} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
