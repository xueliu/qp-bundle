<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP-nano: Preemptive Run-to-Completion QK-nano Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id="logo" title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com"></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QP-nano
   &#160;<span id="projectnumber">6.8.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arm-cm_qk.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Preemptive Run-to-Completion QK-nano Kernel </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#arm-cm_qk-synopsis">Synopsis of the QK-nano Port on ARM Cortex-M</a><ul><li class="level2"><a href="#arm-cm_qk-preempt">Preemption Scenarios in QK-nano on ARM Cortex-M</a></li>
</ul>
</li>
<li class="level1"><a href="#arm-cm_qk-qf_port">The qf_port.h Header File</a></li>
<li class="level1"><a href="#arm-cm_qk-qk_port">The qk_port.h Header File</a></li>
<li class="level1"><a href="#arm-cm_qk-qk_impl">QK-nano Port Implementation for ARM Cortex-M</a><ul><li class="level2"><a href="#arm-cm_qk_port-asm_init">QK_init() Implementation</a></li>
<li class="level2"><a href="#arm-cm_qk_port-asm_pendsv">PendSV_Handler() Implementation</a></li>
<li class="level2"><a href="#arm-cm_qk_port-asm_nmi">NMI_Handler() Implementation</a></li>
</ul>
</li>
<li class="level1"><a href="#arm-cm_qk-isr">Writing ISRs for QK</a></li>
<li class="level1"><a href="#arm-cm_qk-fpu">Using the FPU in the QK-nano Port (Cortex-M4F)</a><ul><li class="level2"><a href="#arm-cm_qk-fpu_1thread">FPU used in ONE thread only and not in any ISR</a></li>
<li class="level2"><a href="#arm-cm_qk-fpu_nthreadd">FPU used in more than one thread only or the ISR</a></li>
</ul>
</li>
<li class="level1"><a href="#arm-cm_qk-idle">QK-nano Idle Processing Customization in QK_onIdle()</a></li>
<li class="level1"><a href="#arm-cm_qk-testing">Testing QK-nano Preemption Scenarios</a><ul><li class="level2"><a href="#arm-cm_qk-test-isr">Interrupt Nesting Test</a></li>
<li class="level2"><a href="#arm-cm_qk-test-thread">Thread Preemption Test</a></li>
<li class="level2"><a href="#arm-cm_qk-test-fpu">Testing the FPU (Cortex-M4F)</a></li>
<li class="level2"><a href="#arm-cm_qk-test-other">Other Tests</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The preemptive, run-to-completion (RTC) QK-nano kernel breaks entirely with the endless-loop structure of the thread routines and instead uses threads structured as one-shot, discrete, run-to-completion functions, very much like ISRs [PSiCC2, Chapter 10]. In fact, the QK-nano kernel views interrupts very much like threads of a "super-high" priority, except that interrupts are prioritized in hardware by the interrupt controller, whereas threads are prioritized in software by the RTC kernel. </p>
<dl class="section note"><dt>Note</dt><dd>The preemptive QK-nano kernel uses only one stack for all threads (see the next section), but the stack must be bigger than in the non-preemptive QV kernel. You need to adjust the size of this stack to be large enough for your application.</dd></dl>
<p>As a fully preemptive multithreading kernel, QK-nano must ensure that at all times the CPU executes the highest-priority thread (active object) that is ready to run. Fortunately, only two scenarios can lead to readying a higher-priority thread:</p>
<ul class="tag">
<li>
<span class="tag">1</span> When a lower-priority thread posts an event to a higher-priority thread, the kernel must immediately suspend the execution of the lower-priority thread and start the higher-priority thread. This type of preemption is called <b>synchronous preemption</b> because it happens synchronously with posting an event to the thread's event queue. <blockquote class="doxtable">
<p>NOTE: The stack usage shown in the bottom panel displays stack growing down (towards lower addresses), as it is the case in ARM Cortex-M. </p>
</blockquote>
</li>
</ul>
<p><a class="anchor" id="arm-cm_qk-synch-fig"></a></p><div class="image">
<img src="qk_synch.gif" alt=""/>
<div class="caption">
Synchronous Preemption in QK</div></div>
<ul class="tag">
<li>
<span class="tag">2</span> When an interrupt posts an event to a higher-priority thread than the interrupted thread, upon completion of the ISR the kernel must start execution of the higher-priority thread instead of resuming the lower-priority thread. This type of preemption is called <b>asynchronous preemption</b> because it can happen asynchronously, any time interrupts are not explicitly disabled. <blockquote class="doxtable">
<p>NOTE: The stack usage during asynchronous preemption on ARM Cortex-M is slightly simplified in the diagram below. A more detailed stack usage diagram is discussed later in the section explaining the "Detailed stack allocation in QK-nano for ARM Cortex-M". </p>
</blockquote>
</li>
</ul>
<p><a class="anchor" id="arm-cm_qk-asynch-fig"></a></p><div class="image">
<img src="qk_asynch.gif" alt=""/>
<div class="caption">
Synchronous Preemption in QK</div></div>
<dl class="section note"><dt>Note</dt><dd>A traditional RTOS kernel does not distinguish between the synchronous and asynchronous preemptions and makes all preemptions look like the more stack-intensive asynchronous preemptions. In contrast, a RTC kernel can implement synchronous preemption as a simple function call (to <a class="el" href="qkn_8h.html#a57768dcdb71b3e41f329bae839584399" title="QK activator activates the next active object.">QK_activate_()</a>), which is much more efficient than a full context-switch.</dd></dl>
<hr  />
 <h1><a class="anchor" id="arm-cm_qk-synopsis"></a>
Synopsis of the QK-nano Port on ARM Cortex-M</h1>
<p>The ARM Cortex-M architecture is designed primarily for the traditional real-time kernels that use multiple per-thread stacks. This section explains how the run-to-completion preemptive QK-nano kernel works on ARM Cortex-M.</p>
<ol type="1">
<li>The ARM Cortex-M processor executes the QK-nano application code (active objects) in the Privileged Thread mode, which is exactly the mode entered out of reset. The exceptions (including all interrupts) are always processed in the Privileged Handler mode.</li>
<li>QK-nano uses only the Main Stack Pointer (QK-nano is a single stack kernel). The Process Stack Pointer is not used and is not initialized.</li>
<li>ARM Cortex-M enters interrupt context without disabling interrupts (without setting the PRIMASK bit or the BASEPRI register). Generally, you should not disable interrupts inside your ISRs. In particular, the QP services QF_PUBLISH(), QF_TICK_X(), and <a class="el" href="qfn_8h.html#ac41ac57f925509fc92f9b3612f8c03b5" title="Polymorphically posts an event to an active object (FIFO) with delivery guarantee (task context).">QACTIVE_POST()</a> should be called with interrupts enabled, to avoid nesting of critical sections. (NOTE: If you don’t wish an interrupt to be preempted by another interrupt, you can always prioritize that interrupt in the NVIC to a higher level &ndash; use a lower numerical value of priority).</li>
<li>The QK-nano port uses the PendSV exception (number 14) and the NMI exception (number 2) to perform asynchronous preemption and return to the preempted thread, respectively (see Chapter 10 in [<a href="https://www.state-machine.com/psicc2/" target="_blank" class="extern">PSiCC2</a>]). The startup code must initialize the Interrupt Vector Table with the addresses of <code>PendSV_Handler()</code> and <code>NMI_Handler()</code> exception handlers.</li>
<li>The <a class="el" href="qfn_8h.html#a1e56e284f4f0336a56f5ea8e6520295e" title="QF-nano initialization.">QF_init()</a> function calls the function <a class="el" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init()</a> to set the priority of the PendSV exception to the lowest level in the whole system (0xFF). The function <a class="el" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init()</a> additionally sets the interrupt priority of all IRQs available in the MCU to the safe value of <code>QF_BASEPRI</code> (for ARM-v7 architecture).</li>
<li>It is strongly recommended that you do not assign the lowest priority (0xFF) to any interrupt in your application. With 3 MSB-bits of priority, this leaves the following 7 priority levels for you (listed from the lowest to the highest urgency): 0xC0, 0xA0, 0x80, 0x60, 0x40, 0x20, and 0x00 (the highest priority).</li>
<li>Before returning, every "kernel aware" ISR must check whether an active object has been activated that has a higher priority than the currently running active object. If this is the case, the ISR must set the PensSV pending flag in the NVIC. All this is accomplished in the macro <a class="el" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="QK-nano ISR exit.">QK_ISR_EXIT()</a>, which must be called just before exiting every ISRs.</li>
<li>In ARM Cortex-M the whole prioritization of interrupts, including the PendSV exception, is performed entirely by the NVIC. Because the PendSV has the lowest priority in the system, the NVIC tail-chains to the PendSV exception only after exiting the last nested interrupt.</li>
<li>The pushing of the 8 registers comprising the ARM Cortex-M interrupt stack frame upon entry to NMI exception is wasteful in a single-stack kernel, but is necessary to perform full interrupt return to the preempted context through the NMI's return.</li>
</ol>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk-preempt"></a>
Preemption Scenarios in QK-nano on ARM Cortex-M</h2>
<p><a class="anchor" id="arm-cm_qk-arm-cm-fig"></a></p><div class="image">
<img src="qk_arm-cm.gif" alt=""/>
<div class="caption">
Several preemption scenarios in QK</div></div>
<ul class="tag">
<li>
<span class="tag">0</span> The timeline begins with the QK-nano executing the idle loop.  </li>
<li>
<span class="tag">1</span> At some point an interrupt occurs and the CPU immediately suspends the idle loop, pushes the interrupt stack frame to the Main Stack and starts executing the ISR.  </li>
<li>
<span class="tag">2</span> The ISR performs its work, and in QK-nano always must call the <a class="el" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="QK-nano ISR exit.">QK_ISR_EXIT()</a> macro, which calls the QK-nano scheduler to determine if there is a higher-priority AO to run. If so, the macro sets the pending flag for the PendSV exception in the NVIC. The priority of the PendSV exception is configured to be the lowest of all exceptions, so the ISR continues executing and PendSV exception remains pending. At the ISR return, the ARM Cortex-M CPU performs tail-chaining to the pending PendSV exception.  </li>
<li>
<p class="startli"><span class="tag">3</span> The PendSV exception discovers whether there is a higher-priority thread to run then the preempted one (by calling QK_schedPrio_()) and if so, to to synthesize an exception stack frame to return to the QK-nano scheduler (<a class="el" href="qkn_8h.html#a49a6ff5d3a7c6ae58e33a2b943efb2fc" title="QK-nano scheduler finds the highest-priority thread ready to run.">QK_sched_()</a>) to run this new thread. </p><blockquote class="doxtable">
<p>NOTE: The QK-nano scheduler must run in the thread context, while PendSV executes in the exception context. The change of the context is accomplished by returning from the PendSV exception directly to the QK-nano scheduler. </p>
</blockquote>
<p class="endli">To return directly to the QK-nano scheduler, PendSV synthesizes an exception stack frame, which contains the exception return address set to <a class="el" href="qkn_8h.html#a49a6ff5d3a7c6ae58e33a2b943efb2fc" title="QK-nano scheduler finds the highest-priority thread ready to run.">QK_sched_()</a>. The QK-nano scheduler discovers that the Low-priority thread is ready to run (the ISR has posted event to this thread). The QK-nano scheduler enables interrupts and launches the Low-priority thread, which is simply a C-function call in QK. The Low-priority thread (active object) starts running.  </p>
</li>
<li>
<span class="tag">4</span> Some time later a low-priority interrupt occurs. The Low-priority thread is suspended and the CPU pushes the interrupt stack frame to the Main Stack and starts executing the ISR.  </li>
<li>
<span class="tag">5</span> Before the Low-priority ISR completes, it too gets preempted by a High-priority ISR. The CPU pushes another interrupt stack frame and starts executing the High-priority ISR.  </li>
<li>
<span class="tag">6</span> The High-priority ISR sets the pending flag for the PendSV exception by means of the <a class="el" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="QK-nano ISR exit.">QK_ISR_EXIT()</a> macro. When the High-priority ISR returns, the NVIC does not tail-chain to the PendSV exception, because a higher-priority ISR than PendSV is still active. The NVIC performs an exception return to the preempted Low-priority interrupt, which finally completes.  </li>
<li>
<span class="tag">7</span> Upon the exit from the Low-priority ISR, it too sets the pending flag for the PendSV exception by means of the <a class="el" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="QK-nano ISR exit.">QK_ISR_EXIT()</a> macro. The PendSV is already pended from the High-priority interrupt, so pending is again is redundant, but it is not an error. At the ISR return, the ARM Cortex-M CPU performs tail-chaining to the pending PendSV exception.  </li>
<li>
<span class="tag">8</span> The PendSV exception synthesizes an interrupt stack frame to return to the QK-nano scheduler. The QK-nano scheduler detects that the High-priority thread is ready to run and launches the High-priority thread (normal C-function call). The High-priority thread runs to completion and returns to the scheduler.  </li>
<li>
<span class="tag">9</span> The QK-nano scheduler does not find any more higher-priority threads to execute and needs to return to the preempted thread. The only way to restore the interrupted context in ARM Cortex-M is through the interrupt return, but the thread is executing outside of the interrupt context (in fact, threads are executing in the Privileged Thread mode). The thread enters the Handler mode by pending the NMI exception. <blockquote class="doxtable">
<p>NOTE: The NMI exception is pended while interrupts are still disabled. This is not a problem, because NMI cannot be masked by disabling interrupts, so runs without any problems. </p>
</blockquote>
</li>
<li>
<span class="tag">10</span> The only job of the NMI exception is to discard its own interrupt stack frame, re-enable interrupts, and return using the interrupt stack frame that has been on the stack from the moment of thread preemption.  </li>
<li>
<span class="tag">11</span> The Low-priority thread, which has been preempted all that time, resumes and finally runs to completion and returns to the QK-nano scheduler. The QK-nano scheduler does not find any more threads to launch and causes the NMI exception to return to the preempted thread.  </li>
<li>
<span class="tag">12</span> The NMI exception discards its own interrupt stack frame and returns using the interrupt stack frame from the preempted thread context  </li>
</ul>
<hr  />
 <h1><a class="anchor" id="arm-cm_qk-qf_port"></a>
The qf_port.h Header File</h1>
<p>The QF header file for the ARM Cortex-M port is located in <span class="img file_h">/ports/arm-cm/qk/gnu/qf_port.h</span>. This file is almost identical to the <a class="el" href="arm-cm_qv.html#arm-cm_qv-qf_port">QV port</a>, except the header file in the QK-nano port includes <code>qk_port.h</code> header file instead of <code>qv_porth</code>.</p>
<hr  />
 <h1><a class="anchor" id="arm-cm_qk-qk_port"></a>
The qk_port.h Header File</h1>
<p>You configure and customize QK-nano through the header file qk_port.h, which is located in the QP ports directory <span class="img folder">/ports/arm-cm/qk/gnu/</span>. The most important function of <span class="img file_h">qk_port.h</span> is specifying interrupt entry and exit.</p>
<dl class="section note"><dt>Note</dt><dd>As any preemptive kernel, QK-nano needs to be notified about entering the interrupt context and about exiting an interrupt context in order to perform a context switch, if necessary.</dd></dl>
<p><a class="anchor" id="arm-cm_qk_port-code"></a><b>Listing: qk_port.h header file for ARM Cortex-M</b> </p><div class="fragment"><div class="line">    <span class="comment">/* determination if the code executes in the ISR context */</span></div>
<div class="line">[1] #define QK_ISR_CONTEXT_() (QK_get_IPSR() != (<a class="code" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>)0)</div>
<div class="line"> </div>
<div class="line">    __attribute__((always_inline))</div>
<div class="line">[2] <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> QK_get_IPSR(<span class="keywordtype">void</span>) {</div>
<div class="line">        <a class="code" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> regIPSR;</div>
<div class="line">        __asm <span class="keyword">volatile</span> (<span class="stringliteral">&quot;mrs %0,ipsr&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (regIPSR));</div>
<div class="line">        <span class="keywordflow">return</span> regIPSR;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* QK-nano interrupt entry and exit */</span></div>
<div class="line">[3] #define <a class="code" href="qkn_2qfn__port_8h.html#ad3a6c9c79a8f39f1299196922e3eb6b5">QK_ISR_ENTRY</a>() ((void)0)</div>
<div class="line"> </div>
<div class="line">[4] #define <a class="code" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b">QK_ISR_EXIT</a>()  do { \</div>
<div class="line">[5]     <a class="code" href="qkn_2qfn__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>(); \</div>
<div class="line">[6]     <span class="keywordflow">if</span> (<a class="code" href="qkn_8h.html#a49a6ff5d3a7c6ae58e33a2b943efb2fc">QK_sched_</a>() != (<a class="code" href="stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a>)0) { \</div>
<div class="line">[7]        (*<a class="code" href="qepn_8h.html#a7a86725df60bb442ac834093a779726f">Q_UINT2PTR_CAST</a>(<a class="code" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>, 0xE000ED04U) = (<a class="code" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>)(1U &lt;&lt; 28)); \</div>
<div class="line">        } \</div>
<div class="line">[8]     <a class="code" href="qkn_2qfn__port_8h.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>(); \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialization of the QK-nano kernel */</span></div>
<div class="line">[9] #define <a class="code" href="qkn_2qfn__port_8h.html#a1e726be02d56193ed854282969834806">QK_INIT</a>() <a class="code" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a>()</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a>(<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">#include &quot;qk.h&quot; </span><span class="comment">/* QK-nano platform-independent public interface */</span><span class="preprocessor"></span></div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The macro <code>QK_ISR_CONTEXT()</code> returns true when the code executes in the ISR context and false otherwise. The macro takes advantage of the ARM Cortex-M register IPSR, which is non-zero when the CPU executes an exception (or interrupt) and is zero when the CPU is executing thread code. <blockquote class="doxtable">
<p>NOTE: QK-nano needs to distinguish between ISR and thread contexts, because threads need to perform synchronous context switch (when a higher-priority thread becomes ready to run), while ISRs should not do that. </p>
</blockquote>
</li>
<li>
<span class="tag">2</span> The inline function <code>QK_get_IPSR()</code> obtains the IPSR register and returns it to the caller. This function is defined explicitly for the GNU-ARM toolchain, but many other toolchains provide this function as an intrinsic, built-in facility.  </li>
<li>
<span class="tag">3</span> The <code><a class="el" href="qkn_2qfn__port_8h.html#ad3a6c9c79a8f39f1299196922e3eb6b5" title="QK-nano ISR entry.">QK_ISR_ENTRY()</a></code> macro notifies QK-nano about entering an ISR. The macro is empty, because the determination of the ISR vs thread context is performed independently in the <code>QK_ISR_CONTEXT()</code> macro (see above).  </li>
<li>
<span class="tag">4</span> The <code><a class="el" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="QK-nano ISR exit.">QK_ISR_EXIT()</a></code> macro notifies QK-nano about exiting an ISR.  </li>
<li>
<span class="tag">5</span> Interrupts are disabled before calling QK-nano scheduler.  </li>
<li>
<span class="tag">6</span> The QK-nano scheduler is called to find out whether an active object of a higher priority than the current one needs activation. The <code><a class="el" href="qkn_8h.html#a49a6ff5d3a7c6ae58e33a2b943efb2fc" title="QK-nano scheduler finds the highest-priority thread ready to run.">QK_sched_()</a></code> function returns non zero value if this is the case.  </li>
<li>
<span class="tag">7</span> If asynchronous preemption becomes necessary, the code sets the PENDSV Pend bit(28) in the ICSR register (Interrupt Control and State Register). The register is mapped at address 0xE000ED04 in all ARM Cortex-M cores.  </li>
<li>
<span class="tag">8</span> The interrupts are re-enabled after they have been disabled in step [5]. <blockquote class="doxtable">
<p>NOTE: Because the priority of the PendSV exception is the lowest of all interrupts, it is actually triggered only after all nested interrupts exit. The PendSV exception is then entered through the efficient <b>tail-chaining</b> process, which eliminates the restoring and re-entering the interrupt context. </p>
</blockquote>
</li>
</ul>
<hr  />
 <h1><a class="anchor" id="arm-cm_qk-qk_impl"></a>
QK-nano Port Implementation for ARM Cortex-M</h1>
<p>The QK-nano port to ARM Cortex-M requires coding the PendSV and NMI exceptions in assembly. This ARM Cortex-M-specific code, as well as QK-nano initialization (<code><a class="el" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init()</a></code>) is located in the file <span class="img file">­ports/arm-cm/­qk/­gnu/qk_port.c</span></p>
<dl class="section note"><dt>Note</dt><dd>The single assembly module <code>qk_port.s</code> contains common code for all Cortex-M variants (Architecture v6M and v7M) as well as options with and without the VFP. The CPU variants are distinguished by conditional compilation, when necessary.</dd></dl>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk_port-asm_init"></a>
QK_init() Implementation</h2>
<p><b>Listing: QK_init function in qk_port.s assembly file</b> </p><div class="fragment"><div class="line"><span class="comment">     /*****************************************************************************</span></div>
<div class="line"><span class="comment">     * The QK_init() function sets the priority of PendSV to 0xFF (lowest urgency).</span></div>
<div class="line"><span class="comment">     * For Cortex-M3/4/7, it also sets priorities of all other exceptions and IRQs</span></div>
<div class="line"><span class="comment">     * to the safe value. All this is performed in a nestable critical section.</span></div>
<div class="line"><span class="comment">                                                                                 */</span></div>
<div class="line">         .section .text.QK_init</div>
<div class="line">         .global <a class="code" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a></div>
<div class="line">         .type   <a class="code" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a>, %<span class="keyword">function</span></div>
<div class="line"> </div>
<div class="line"> [1] <a class="code" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a>:</div>
<div class="line"> </div>
<div class="line"> [2]     MRS     r0,PRIMASK        <span class="comment">/* store the state of the PRIMASK in r0 */</span></div>
<div class="line"> [3]     MOV     r12,r0            <span class="comment">/* r12 := PRIMASK */</span></div>
<div class="line"> [4]     CPSID   i                 <span class="comment">/* PRIMASK := 1 */</span></div>
<div class="line"> </div>
<div class="line"> [5]   .if  __ARM_ARCH == 6        <span class="comment">/* Cortex-M0/M0+/M1 (v6-M, v6S-M)? */</span></div>
<div class="line"> </div>
<div class="line"> [6]     LDR     r3,=0xE000ED18    <span class="comment">/* System Handler Priority Register */</span></div>
<div class="line"> [7]     LDR     r2,[r3,#8]        <span class="comment">/* r2 := SYSPRI3 */</span></div>
<div class="line"> [8]     MOVS    r0,#0xFF</div>
<div class="line"> [9]     LSLS    r0,r0,#16</div>
<div class="line">[10]     ORRS    r2,r1</div>
<div class="line">[11]     STR     r2,[r3,#8]        <span class="comment">/* SYSPRI3 := r2, PendSV &lt;- 0xFF */</span></div>
<div class="line"> </div>
<div class="line">[12]   .else                       <span class="comment">/* M3/M4 */</span></div>
<div class="line">         <span class="comment">/* NOTE:</span></div>
<div class="line"><span class="comment">         * On Cortex-M3/M4/.., this QK-nano port disables interrupts by means of the</span></div>
<div class="line"><span class="comment">         * BASEPRI register. However, this method cannot disable interrupt</span></div>
<div class="line"><span class="comment">         * priority zero, which is the default for all interrupts out of reset.</span></div>
<div class="line"><span class="comment">         * The following code changes the SysTick priority and all IRQ priorities</span></div>
<div class="line"><span class="comment">         * to the safe value QF_BASEPRI, wich the QF critical section can disable.</span></div>
<div class="line"><span class="comment">         * This avoids breaching of the QF critical sections in case the</span></div>
<div class="line"><span class="comment">         * application programmer forgets to explicitly set priorities of all</span></div>
<div class="line"><span class="comment">         * &quot;kernel aware&quot; interrupts.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* set all priority bytes to QF_BASEPRI in r1 */</span></div>
<div class="line">[13]     MOVS    r1,#QF_BASEPRI</div>
<div class="line">         LSLS    r1,r1,#8</div>
<div class="line">         ORRS    r1,r1,#QF_BASEPRI</div>
<div class="line">         LSLS    r1,r1,#8</div>
<div class="line">         ORRS    r1,r1,#QF_BASEPRI</div>
<div class="line">         LSLS    r1,r1,#8</div>
<div class="line">         ORRS    r1,r1,#QF_BASEPRI</div>
<div class="line"> </div>
<div class="line">         LDR     r3,=0xE000ED18    <span class="comment">/* System Handler Priority Register */</span></div>
<div class="line">         LDR     r2,[r3]           <span class="comment">/* r2 := SYSPRI1 */</span></div>
<div class="line">         ORRS    r2,r1             <span class="comment">/* r2 |= &quot;all values to QF_BASEPRI&quot; */</span></div>
<div class="line">[14]     STR     r2,[r3]           <span class="comment">/* SYSPRI1 |= r2, Use-fault/Bus-fault/Mem-fault*/</span></div>
<div class="line"> </div>
<div class="line">         LDR     r2,[r3,#4]        <span class="comment">/* r2 := SYSPRI2 */</span></div>
<div class="line">         ORRS    r2,r1             <span class="comment">/* r2 |= &quot;all values to QF_BASEPRI&quot; */</span></div>
<div class="line">[16]     STR     r2,[r3,#4]        <span class="comment">/* SYSPRI2 := r2, SVCall */</span></div>
<div class="line"> </div>
<div class="line">         LDR     r2,[r3,#8]        <span class="comment">/* r2 := SYSPRI3 */</span></div>
<div class="line">         ORRS    r1,r1,#(0xFF &lt;&lt; 16) <span class="comment">/* r1 |= 0xFF for PendSV */</span></div>
<div class="line">         ORRS    r2,r1</div>
<div class="line">[17]     STR     r2,[r3,#8]        <span class="comment">/* SYSPRI3 |= r2, SysTick/PendSV/Debug */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* set again all prioriy bytes to QF_BASEPRI in r1 */</span></div>
<div class="line">[18]     MOVS    r1,#QF_BASEPRI</div>
<div class="line">         LSLS    r1,r1,#8</div>
<div class="line">         ORRS    r1,r1,#QF_BASEPRI</div>
<div class="line">         LSLS    r1,r1,#8</div>
<div class="line">         ORRS    r1,r1,#QF_BASEPRI</div>
<div class="line">         LSLS    r1,r1,#8</div>
<div class="line">         ORRS    r1,r1,#QF_BASEPRI</div>
<div class="line"> </div>
<div class="line">[19]     LDR     r3,=0xE000E004    <span class="comment">/* Interrupt Controller Type Register */</span></div>
<div class="line">         LDR     r3,[r3]           <span class="comment">/* r3 := INTLINESUM */</span></div>
<div class="line">         LSLS    r3,r3,#3</div>
<div class="line">[20]     ADDS    r3,r3,#8          <span class="comment">/* r3 == number of NVIC_PRIO registers */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* loop over all implemented NVIC_PRIO registers for IRQs... */</span></div>
<div class="line">     QK_init_irq:</div>
<div class="line">         SUBS    r3,r3,#1</div>
<div class="line">         LDR     r2,=0xE000E400    <span class="comment">/* NVIC_PRI0 register */</span></div>
<div class="line">[21]     STR     r1,[r2,r3,LSL #2] <span class="comment">/* NVIC_PRI0[r3]  := r1 */</span></div>
<div class="line">         CMP     r3,#0</div>
<div class="line">         BNE     QK_init_irq</div>
<div class="line"> </div>
<div class="line">       .endif                      <span class="comment">/* M3/M4 */</span></div>
<div class="line"> </div>
<div class="line">[22]     MOV     r0,r12            <span class="comment">/* r0 := original PRIMASK */</span></div>
<div class="line">[23]     MSR     PRIMASK,r0        <span class="comment">/* PRIMASK := r0 */</span></div>
<div class="line">[24]     BX      lr</div>
<div class="line">       .size   <a class="code" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a>, . - <a class="code" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a></div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The <a class="el" href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init()</a> function initializes the exception priorities of PendSV and NMI as well as interrupt priorities of all IRQs available in a given MCU (for Cortex-M3/4/7).  </li>
<li>
<span class="tag">2</span> The PRIMASK register is retreived into r0.  </li>
<li>
<span class="tag">3</span> The PRIMASK value is stored in the high-register r12.  </li>
<li>
<p class="startli"><span class="tag">4</span> Interrupts are disabled by setting the PRIMASK. </p>
<p class="endli"></p>
</li>
<li>
<span class="tag">5</span> For the ARMv6-M architecture...  </li>
<li>
<span class="tag">6</span> The address of the NVIC System Handler Priority Register 0 is loaded into r3  </li>
<li>
<span class="tag">7</span> The contents of the NVIC System Handler Priority Register 2 (note the offset of 8) is loaded into r2.  </li>
<li>
<span class="tag">8-9</span> The mask value of 0xFF0000 is synthesized in r2.  </li>
<li>
<span class="tag">10</span> The mask is then applied to set the priority byte PRI_14 to 0xFF without changing other priority bytes in this register.  </li>
<li>
<p class="startli"><span class="tag">11</span> The contents of r2 is stored in the NVIC System Handler Priority Register 2 (note the offset of 8). </p>
<p class="endli"></p>
</li>
<li>
<span class="tag">12</span> For the ARMv7-M architecture...  </li>
<li>
<span class="tag">13</span> The priority value QF_BASEPRI is all bytes of the register r1.  </li>
<li>
<span class="tag">14</span> The exception priorities for User-Fault, Bus-Fault, and Mem-Fault are set to the value QF_BASEPRI.  </li>
<li>
<span class="tag">16</span> The exception priority for SVCCall is set to the value QF_BASEPRI.  </li>
<li>
<span class="tag">17</span> The exception priority for SysTick, PendSV, and Debug is set to the value QF_BASEPRI.  </li>
<li>
<span class="tag">18</span> The priority value QF_BASEPRI is all bytes of the register r1 again.  </li>
<li>
<span class="tag">19</span> The value of Interrupt Controller Type Register is loaded into r3  </li>
<li>
<span class="tag">20</span> The number of implemented IRQs is loaded into r3  </li>
<li>
<p class="startli"><span class="tag">21</span> The interrupt priority of all implemented IRQs is set to the safe value QF_BASEPRI in a loop. </p>
<p class="endli"></p>
</li>
<li>
<span class="tag">22</span> The original value of PRIMASK is restored form the high-register r12  </li>
<li>
<span class="tag">23</span> The PRIMASK register is restored to its original value  </li>
<li>
<span class="tag">14</span> The function QK_init returns to the caller.  </li>
</ul>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk_port-asm_pendsv"></a>
PendSV_Handler() Implementation</h2>
<p><b>Listing: PendSV_Handler function in qk_port.s assembly file</b> </p><div class="fragment"><div class="line">         .section .text.PendSV_Handler</div>
<div class="line">         .global PendSV_Handler    <span class="comment">/* CMSIS-compliant exception name */</span></div>
<div class="line">         .type   PendSV_Handler, %<span class="keyword">function</span></div>
<div class="line"> </div>
<div class="line"> [1] PendSV_Handler:</div>
<div class="line">         <span class="comment">/* Prepare some constants in registers before entering critical section */</span></div>
<div class="line"> [2]     LDR     r3,=0xE000ED04    <span class="comment">/* Interrupt Control and State Register */</span></div>
<div class="line"> [3]     MOVS    r1,#1</div>
<div class="line"> [4]     LSLS    r1,r1,#27         <span class="comment">/* r0 := (1 &lt;&lt; 27) (UNPENDSVSET bit) */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; CRITICAL SECTION BEGIN &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; */</span></div>
<div class="line">       .if  __ARM_ARCH == 6        <span class="comment">/* Cortex-M0/M0+/M1 (v6-M, v6S-M)? */</span></div>
<div class="line"> [6]     CPSID   i                 <span class="comment">/* disable interrupts (set PRIMASK) */</span></div>
<div class="line">       .else                       <span class="comment">/* M3/M4 */</span></div>
<div class="line">       .ifdef  __FPU_PRESENT       <span class="comment">/* if VFP available... */</span></div>
<div class="line"> [7]     PUSH    {r0,lr}           <span class="comment">/* ... push EXC_RETURN plus stack-aligner */</span></div>
<div class="line">       .endif                      <span class="comment">/* VFP */</span></div>
<div class="line"> [8]     MOVS    r0,#QF_BASEPRI</div>
<div class="line"> [9]     CPSID   i                 <span class="comment">/* selectively disable interrutps with BASEPRI */</span></div>
<div class="line">[10]     MSR     BASEPRI,r0        <span class="comment">/* apply the workaround the Cortex-M7 erraturm */</span></div>
<div class="line">[11]     CPSIE   i                 <span class="comment">/* 837070, see ARM-EPM-064408. */</span></div>
<div class="line">       .endif                      <span class="comment">/* M3/M4 */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* The PendSV exception handler can be preempted by an interrupt,</span></div>
<div class="line"><span class="comment">         * which might pend PendSV exception again. The following write to</span></div>
<div class="line"><span class="comment">         * ICSR[27] un-pends any such spurious instance of PendSV.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">[12]     STR     r1,[r3]           <span class="comment">/* ICSR[27] := 1 (unpend PendSV) */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* The QK-nano activator must be called in a Thread mode, while this code</span></div>
<div class="line"><span class="comment">         * executes in the Handler mode of the PendSV exception. The switch</span></div>
<div class="line"><span class="comment">         * to the Thread mode is accomplished by returning from PendSV using</span></div>
<div class="line"><span class="comment">         * a fabricated exception stack frame, where the return address is</span></div>
<div class="line"><span class="comment">         * QK_activate_().</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * NOTE: the QK-nano activator is called with interrupts DISABLED and also</span></div>
<div class="line"><span class="comment">         * returns with interrupts DISABLED.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">[13]     LSRS    r3,r1,#3          <span class="comment">/* r3 := (r1 &gt;&gt; 3), set the T bit (new xpsr) */</span></div>
<div class="line">[14]     LDR     r2,=<a class="code" href="qkn_8h.html#a57768dcdb71b3e41f329bae839584399">QK_activate_</a>  <span class="comment">/* address of QK_activate_ */</span></div>
<div class="line">[15]     SUBS    r2,r2,#1          <span class="comment">/* align Thumb-address at halfword (new pc) */</span></div>
<div class="line">[16]     LDR     r1,=Thread_ret    <span class="comment">/* return address after the call   (new lr) */</span></div>
<div class="line"> </div>
<div class="line">[17]     SUB     sp,sp,#8*4        <span class="comment">/* reserve space for exception stack frame */</span></div>
<div class="line">[18]     ADD     r0,sp,#5*4        <span class="comment">/* r0 := 5 registers below the top of stack */</span></div>
<div class="line">[19]     STM     r0!,{r1-r3}       <span class="comment">/* save xpsr,pc,lr */</span></div>
<div class="line"> </div>
<div class="line">[20]     MOVS    r0,#6</div>
<div class="line">[21]     MVNS    r0,r0             <span class="comment">/* r0 := ~6 == 0xFFFFFFF9 */</span></div>
<div class="line">[22]     BX      r0                <span class="comment">/* exception-return to the QK-nano activator */</span></div>
<div class="line">       .size   PendSV_Handler, . - PendSV_Handler</div>
<div class="line"> </div>
<div class="line">     <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Thread_ret is a helper function executed when the QXK activator returns.</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * NOTE: Thread_ret does not execute in the PendSV context!</span></div>
<div class="line"><span class="comment">     * NOTE: Thread_ret executes entirely with interrupts DISABLED.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">         .section .text.Thread_ret</div>
<div class="line">         .type   Thread_ret, %<span class="keyword">function</span></div>
<div class="line"> </div>
<div class="line">[23] Thread_ret:</div>
<div class="line">         <span class="comment">/* After the QK-nano activator returns, we need to resume the preempted</span></div>
<div class="line"><span class="comment">         * thread. However, this must be accomplished by a return-from-exception,</span></div>
<div class="line"><span class="comment">         * while we are still in the thread context. The switch to the exception</span></div>
<div class="line"><span class="comment">         * context is accomplished by triggering the NMI exception.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* before triggering the NMI exception, make sure that the</span></div>
<div class="line"><span class="comment">         * VFP stack frame will NOT be used...</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">       .ifdef  __FPU_PRESENT       <span class="comment">/* if VFP available... */</span></div>
<div class="line">[24]     MRS     r0,CONTROL        <span class="comment">/* r0 := CONTROL */</span></div>
<div class="line">[25]     BICS    r0,r0,#4          <span class="comment">/* r0 := r0 &amp; ~4 (FPCA bit) */</span></div>
<div class="line">[26]     MSR     CONTROL,r0        <span class="comment">/* CONTROL := r0 (clear CONTROL[2] FPCA bit) */</span></div>
<div class="line">[27]     ISB                       <span class="comment">/* ISB after MSR CONTROL (ARM AN321,Sect.4.16)*/</span></div>
<div class="line">       .endif                      <span class="comment">/* VFP available */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* trigger NMI to return to preempted thread...</span></div>
<div class="line"><span class="comment">         * NOTE: The NMI exception is triggered with nterrupts DISABLED</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">[28]     LDR     r0,=0xE000ED04    <span class="comment">/* Interrupt Control and State Register */</span></div>
<div class="line">[29]     LSLS    r1,r1,#31         <span class="comment">/* r1 := (1 &lt;&lt; 31) (NMI bit) */</span></div>
<div class="line">[30]     MOVS    r1,#1</div>
<div class="line">[31]     STR     r1,[r0]           <span class="comment">/* ICSR[31] := 1 (pend NMI) */</span></div>
<div class="line">[32]     B       .                 <span class="comment">/* wait for preemption by NMI */</span></div>
<div class="line">       .size   Thread_ret, . - Thread_ret</div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> <code>PendSV_Handler</code> is a CMSIS-complinat name of the PendSV exception handler. The <code>PendSV_Handler</code> exception is always entered via tail-chaining from the last nested interrupt.  </li>
<li>
<span class="tag">2-4</span> Before interrupts are disabled, the following constants are loaded into registers: address of ICSR into r3 and (1&lt;&lt;27) into r1.  </li>
<li>
For the ARMv6-M architecture (Cortex-M0/M0+)...  </li>
<li>
<span class="tag">6</span> Interrupts are globally disabled by setting PRIMASK (see Section 3)  </li>
<li>
Otherwise, for the ARMv7-M architecture (Cortex-M3/4/7) and when the <code>_FPU_PRESENT</code> macro is defined... <blockquote class="doxtable">
<p>NOTE: The symbol <code>__FPU_PRESENT</code> must be defined on the command-line to the GNU-ARM assembler if you intend to use the FPU on the Cortex-M4F cores. </p>
</blockquote>
</li>
<li>
<span class="tag">7</span> The lr register (EXC_RETURN) is pushed to the stack along with r0, to keep the stack aligned at 8-byte boundary. <blockquote class="doxtable">
<p>NOTE: In the presence of the FPU (Cortex-M4F), the EXC_RETURN[4] bit carries the information about the stack frame format used, whereas EXC_RETURN[4] ==0 means that the stack contains room for the S0-S15 and FPSCR registers in addition to the usual R0-R3,R12,LR,PC,xPSR registers. This information must be preserved, in order to properly return from the exception at the end. </p>
</blockquote>
</li>
<li>
<span class="tag">8</span> For the ARMv7-M architecture (Cortex-M3/M4), interrupts are selectively disabled by setting the BASEPRI register. <blockquote class="doxtable">
<p>NOTE: The value moved to BASEPRI must be identical to the QF_BASEPRI macro defined in <code>qf_port.h</code>. </p>
</blockquote>
</li>
<li>
<span class="tag">9</span> Before setting the BASEPRI register, interrupts are disabled with the PRIMASK register, which is the recommended workaround for the Cortex-M7 r0p1 hardware bug, as described in the ARM Ltd. [<a class="el" href="arm-cm.html#ARM-EPM-064408">ARM-EPM-064408</a>], Erratum 837070.  </li>
<li>
<span class="tag">10</span> The BASEPRI register is set to the <code>QF_BASEPRI</code> value.  </li>
<li>
<span class="tag">11</span> After setting the BASEPRI register, interrupts are re-anabed with the PRIMASK register, which is the recommended workaround for the Cortex-M7 r0p1 hardware bug, as described in the ARM Ltd. [<a class="el" href="arm-cm.html#ARM-EPM-064408">ARM-EPM-064408</a>], Erratum 837070.  </li>
<li>
<p class="startli"><span class="tag">12</span> The PendSV exception is <b>explicitly</b> un-pended. </p><blockquote class="doxtable">
<p>NOTE: The PendSV exception handler can be preempted by an interrupt, which might pend PendSV exception again. This would trigger PendSV incorrectly again immediately after calling QK-nano activator. </p>
</blockquote>
<p class="endli"></p>
</li>
<li>
The following code [13-22] fabricates an exception stack frame, to perform an exception-return to the QK-nano activator without destroying the original exception stack frame of the PendSV exception. This is necessary to preserve the context of the preempted code.  </li>
<li>
<span class="tag">13</span> The value (1 &lt;&lt; 24) is synthesized in r3 from the value (1 &lt;&lt; 27) already available in r1. This value is going to be stacked and later restored to xPSR register (only the T bit set).  </li>
<li>
<span class="tag">14</span> The address of the QK-nano activator function <code>QK_activate_</code> is loaded into r2. This will be pushed to the stack as the PC register value.  </li>
<li>
<span class="tag">15</span> The address of the QK-nano activator function <code>QK_activate_</code> in r2 is adjusted to be half-word aligned instead of being an odd THUMB address. <blockquote class="doxtable">
<p>NOTE: This is necessary, because the value will be loaded directly to the PC, which cannot accept odd values. </p>
</blockquote>
</li>
<li>
<span class="tag">16</span> The address of the Thread_ret function is loaded into r1. This will be pushed to the stack as the lr register value. <blockquote class="doxtable">
<p>NOTE: The address of the <code>Thread_ret</code> label must be a THUMB address, that is, the least-significant bit of this address must be set (this address must be odd number). This is essential for the correct return of the QK-nano scheduler with setting the THUMB bit in the PSR. Without the LS-bit set, the ARM Cortex-M CPU will clear the T bit in the PSR and cause the Hard Fault. The GNU-ARM assembler/linker will synthesize the correct THUMB address of the svc_ret label only if this label is declared with the <code>.type Thread_ret , function</code> attribute (see step [23]). </p>
</blockquote>
</li>
<li>
<span class="tag">16</span> The stack pointer is adjusted to leave room for 8 registers.  </li>
<li>
<span class="tag">18</span> The top of stack, adjusted by 5 registers, (r0, r1, r2, r3, and r12) is stored to r0.  </li>
<li>
<span class="tag">19</span> The values of xpsr, pc, and lr prepared in r3, r2, and r1, respectively, are pushed on the top of stack (now in r0). This operation completes the synthesis of the exception stack frame. After this step the stack looks as follows: <pre>
Hi memory
           (optionally S0-S15, FPSCR), if EXC_RETURN[4]==0
           xPSR
           pc (interrupt return address)
           lr
           r12
           r3
           r2
           r1
           r0
           EXC_RETURN (pushed in step [7] if FPU is present)
old SP --&gt; "aligner"  (pushed in step [7] if FPU is present)
           xPSR == 0x01000000
           PC == QK_activate_
           lr == Thread_ret
           r12  don't care
           r3   don't care
           r2   don't care
           r1   don't care
    SP --&gt; r0   don't care
Low memory
</pre>  </li>
<li>
<p class="startli"><span class="tag">20-21</span> The special exception-return value 0xFFFFFFF9 is synthesized in r0 (two instructions are used to make the code compatible with Cortex-M0, which has no barrel shifter). </p><blockquote class="doxtable">
<p>NOTE: the r0 register is used instead of lr because the Cortex-M0 instruction set cannot manipulate the higher-registers (r9-r15). NOTE: The exception-return value is consistent with the synthesized stack-frame with the lr[4] bit set to 1, which means that the FPU registers are not included in this stack frame. </p>
</blockquote>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="tag">22</span> PendSV exception returns using the special value of the r0 register of 0xFFFFFFF9 (return to Privileged Thread mode using the Main Stack pointer). The synthesized stack frame causes actually a function call to QK_sched_ function in C. </p><blockquote class="doxtable">
<p>NOTE: The return from the PendSV exception just executed switches the ARM Cortex-M core to the Privileged Thread mode. The QK_sched_ function internally re-enables interrupts before launching any thread, so the threads always run in the Thread mode with interrupts enabled and can be preempted by interrupts of any priority. NOTE: In the presence of the FPU, the exception-return to the QK-nano scheduler does not change any of the FPU status bit, such as CONTROL.FPCA or LSPACT. </p>
</blockquote>
<p class="endli"></p>
</li>
<li>
<span class="tag">23</span> The <code>Thread_ret</code> function is the place, where the QK-nano activator <code><a class="el" href="qkn_8h.html#a57768dcdb71b3e41f329bae839584399" title="QK activator activates the next active object.">QK_activate_()</a></code> returns to, because this return address is pushed to the stack in step [16]. Please note that the address of the <code>Thread_ret</code> label must be a THUMB address.  </li>
<li>
<span class="tag">24-27</span> If the FPU is present, the read-modify-write code clears the CONTROL[2] bit [2]. This bit, called CONTROL.FPCA (Floating Point Active), would cause generating the FPU-type stack frame, which you want to avoid in this case (because the NMI exception will certainly not use the FPU). <blockquote class="doxtable">
<p>NOTE: Clearing the CONTROL.FPCA bit occurs with interrupts disabled, so it is protected from a context switch. </p>
</blockquote>
</li>
<li>
<span class="tag">28-31</span> The asynchronous NMI exception is triggered by setting ICSR[31]. The job of this exception is to put the CPU into the exception mode and correctly return to the thread level.  </li>
<li>
<span class="tag">32</span> This endless loop should not be reached, because the NMI exception should preempt the code immediately after step [31]  </li>
</ul>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk_port-asm_nmi"></a>
NMI_Handler() Implementation</h2>
<p><b>Listing: NMI_Handler function in qk_port.s assembly file</b> </p><div class="fragment"><div class="line">        .section .text.NMI_Handler</div>
<div class="line">        .global NMI_Handler</div>
<div class="line">        .type   NMI_Handler, %<span class="keyword">function</span></div>
<div class="line"> </div>
<div class="line">[1]     NMI_Handler:</div>
<div class="line">[2]     ADD     sp,sp,#(8*4)      <span class="comment">/* remove one 8-register exception frame */</span></div>
<div class="line"> </div>
<div class="line">      .<span class="keywordflow">if</span>  __ARM_ARCH == 6        <span class="comment">/* Cortex-M0/M0+/M1 (v6-M, v6S-M)? */</span></div>
<div class="line">[3]     CPSIE   i                 <span class="comment">/* enable interrupts (clear PRIMASK) */</span></div>
<div class="line">[4]     BX      lr                <span class="comment">/* return to the preempted thread */</span></div>
<div class="line">      .<span class="keywordflow">else</span>                       <span class="comment">/* M3/M4 */</span></div>
<div class="line">[5]     MOVS    r0,#0</div>
<div class="line">[6]     MSR     BASEPRI,r0        <span class="comment">/* enable interrupts (clear BASEPRI) */</span></div>
<div class="line">      .ifdef  __FPU_PRESENT       <span class="comment">/* if VFP available... */</span></div>
<div class="line">[7]     POP     {r0,pc}           <span class="comment">/* pop stack &quot;aligner&quot; and EXC_RETURN to PC */</span></div>
<div class="line">      .else                       <span class="comment">/* no VFP */</span></div>
<div class="line">[8]     BX      lr                <span class="comment">/* return to the preempted thread */</span></div>
<div class="line">      .endif                      <span class="comment">/* VFP available */</span></div>
<div class="line">      .endif                      <span class="comment">/* M3/M4 */</span></div>
<div class="line">      .size   NMI_Handler, . - NMI_Handler</div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The <code>NMI_Handler</code> is the CMSIS-compliant name of the NMI exception handler. This exception is triggered after returning from the QK-nano activator in step [31] of the previous listing. The job of NMI is to discard its own stack frame and cause the exception-return to the original preempted thread context. The stack contents just after entering NMI is shown below: <pre>
Hi memory
           (optionally S0-S15, FPSCR), if EXC_RETURN[4]==0
           xPSR
           pc (interrupt return address)
           lr
           r12
           r3
           r2
           r1
           r0
old SP --&gt; EXC_RETURN (pushed in PendSV [7] if FPU is present)
           "aligner"  (pushed in PendSV [7] if FPU is present)
           xPSR don't care
           PC   don't care
           lr   don't care
           r12  don't care
           r3   don't care
           r2   don't care
           r1   don't care
    SP --&gt; r0   don't care
Low memory
</pre>  </li>
<li>
<span class="tag">2</span> The stack pointer is adjusted to un-stack the 8 registers of the interrupt stack frame corresponding to the NMI exception itself. This moves the stack pointer from the "old SP" to "SP" in the picture above, which "uncovers" the original exception stack frame left by the PendSV exception.  </li>
<li>
<span class="tag">3</span> For ARMv6-M, interrupts are enabled by clearing the PRIMASK.  </li>
<li>
<span class="tag">4</span> For ARMv6-M, The NMI exception returns to the preempted thread using the standard EXC_RETURN, which is in lr.  </li>
<li>
<span class="tag">5-6</span> For the ARMv7-M, interrupts are enabled by writing 0 into the BASEPRI register.  </li>
<li>
<span class="tag">7</span> If the FPU is used, the EXC_RETURN and the "stack aligner" saved in PendSV step [7] are popped from the stack into r0 and pc, respectively. Updating the pc causes the return from PendSV.  </li>
<li>
<span class="tag">8</span> Otherwise, NMI returns to the preempted thread using the standard EXC_RETURN, which is in lr.  </li>
</ul>
<p><a class="anchor" id="qk_stack-detail"></a></p><div class="image">
<img src="qk_stack-detail.gif" alt=""/>
<div class="caption">
Detailed stack allocation in QK-nano for ARM Cortex-M</div></div>
<hr  />
 <h1><a class="anchor" id="arm-cm_qk-isr"></a>
Writing ISRs for QK</h1>
<p>The ARM Cortex-M CPU is designed to use regular C functions as exception and interrupt service routines (ISRs).</p>
<dl class="section note"><dt>Note</dt><dd>The ARM EABI (Embedded Application Binary Interface) requires the stack be 8-byte aligned, whereas some compilers guarantee only 4-byte alignment. For that reason, some compilers (e.g., GNU-ARM) provide a way to designate ISR functions as interrupts. For example, the GNU-ARM compiler provides the <code>__attribute__((__interrupt__))</code> designation that will guarantee the 8-byte stack alignment.</dd></dl>
<p>Typically, ISRs are application-specific (with the main purpose to produce events for active objects). Therefore, ISRs are not part of the generic QP port, but rather part of the BSP (Board Support Package).</p>
<p>The following listing shows an example of the SysTick_Handler() ISR (from the DPP example application). This ISR calls the QF_TICK_X() macro to perform QF time-event management.</p>
<p><a class="anchor" id="arm-cm_qk-isr-code"></a><b>Listing: An ISR header for QK</b> </p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> SysTick_Handler(<span class="keywordtype">void</span>) __attribute__((__interrupt__));</div>
<div class="line">    <span class="keywordtype">void</span> SysTick_Handler(<span class="keywordtype">void</span>) {</div>
<div class="line">         ~ ~ ~</div>
<div class="line">[1]      <a class="code" href="qkn_2qfn__port_8h.html#ad3a6c9c79a8f39f1299196922e3eb6b5">QK_ISR_ENTRY</a>();   <span class="comment">/* inform QK-nano about entering an ISR */</span></div>
<div class="line">         ~ ~ ~</div>
<div class="line">         QF_TICK_X(0U, &amp;l_SysTick_Handler); <span class="comment">/* process all armed time events */</span></div>
<div class="line">         ~ ~ ~</div>
<div class="line">[2]      <a class="code" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b">QK_ISR_EXIT</a>();    <span class="comment">/* inform QK-nano about exiting an ISR */</span></div>
<div class="line">    }</div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> Every ISR for QK-nano must call <code><a class="el" href="qkn_2qfn__port_8h.html#ad3a6c9c79a8f39f1299196922e3eb6b5" title="QK-nano ISR entry.">QK_ISR_ENTRY()</a></code> before calling any QP API  </li>
<li>
<span class="tag">2</span> Every ISR for QK-nano must call <code><a class="el" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="QK-nano ISR exit.">QK_ISR_EXIT()</a></code> right before exiting to let the QK-nano kernel schedule an asynchronous preemption, if necessary.  </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The QK-nano port to ARM Cortex-M complies with the requirement of the ARM-EABI to preserve stack pointer alignment at <b>8-byte boundary</b>. Also, all QP examples for ARM Cortex-M comply with the CMSIS naming convention for all exception handlers and IRQ handlers.</dd></dl>
<hr  />
 <h1><a class="anchor" id="arm-cm_qk-fpu"></a>
Using the FPU in the QK-nano Port (Cortex-M4F)</h1>
<p>If you have the Cortex-M4F CPU and your application uses the hardware FPU, it should be enabled because it is turned off out of reset. The CMSIS-compliant way of turning the FPU on looks as follows:</p>
<pre class="fragment">    SCB-&gt;CPACR |= (0xFU &lt;&lt; 20);
</pre><dl class="section note"><dt>Note</dt><dd>The FPU must be enabled before executing any floating point instruction. An attempt to execute a floating point instruction will fault if the FPU is not enabled.</dd></dl>
<p>Depending on wheter or not you use the FPU in your ISRs, the "Vanilla" QP port allows you to configure the FPU in various ways, as described in the following sub-sections.</p>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk-fpu_1thread"></a>
FPU used in ONE thread only and not in any ISR</h2>
<p>If you use the FPU only at a single thread (active object) and none of your ISRs use the FPU, you can setup the FPU not to use the automatic state preservation and not to use the lazy stacking feature as follows:</p>
<pre class="fragment">    FPU-&gt;FPCCR &amp;= ~((1U &lt;&lt; FPU_FPCCR_ASPEN_Pos) | (1U &lt;&lt; FPU_FPCCR_LSPEN_Pos));
</pre><p>With this setting, the Cortex-M4F processor handles the ISRs in the exact-same way as Cortex-M0-M3, that is, only the standard interrupt frame with R0-R3,R12,LR,PC,xPSR is used. This scheme is the fastest and incurs no additional CPU cycles to save and restore the FPU registers.</p>
<dl class="section note"><dt>Note</dt><dd>This FPU setting will lead to FPU errors, if more than one thread or any of the ISRs indeed start to use the FPU</dd></dl>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk-fpu_nthreadd"></a>
FPU used in more than one thread only or the ISR</h2>
<p>If you use the FPU in more than one of the threads (active objects) or in any of your ISRs, you should setup the FPU to use the automatic state preservation and the lazy stacking feature as follows: </p><pre class="fragment">FPU-&gt;FPCCR |= (1U &lt;&lt; FPU_FPCCR_ASPEN_Pos) | (1U &lt;&lt; FPU_FPCCR_LSPEN_Pos);
</pre><p>This is actually the default setting of the hardware FPU and is recommended for the QK-nano port, because it is safer in view of code evolution. Future changes to the application can easily introduce FPU use in multiple active objects, which would be unsafe if the FPU context was not preserved automatically.</p>
<dl class="section note"><dt>Note</dt><dd>As described in the ARM Application Note "Cortex-M4(F) Lazy Stacking and Context Switching" [<a class="el" href="arm-cm.html#ARM-AN298">ARM-AN298</a>], the FPU automatic state saving requires more stack plus additional CPU time to save the FPU registers, but only when the FPU is actually used.</dd></dl>
<hr  />
 <h1><a class="anchor" id="arm-cm_qk-idle"></a>
QK-nano Idle Processing Customization in QK_onIdle()</h1>
<p>QK-nano can very easily detect the situation when no events are available, in which case QK-nano calls the <code><a class="el" href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a></code> callback. You can use <code><a class="el" href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a></code> to suspended the CPU to save power, if your CPU supports such a power-saving mode. Please note that <code><a class="el" href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a></code> is called repetitively from an endless loop, which is the QK-nano idle-thread. The <code><a class="el" href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a></code> callback is called with interrupts <b>enabled</b> (which is in contrast to the <a class="el" href="arm-cm_qv.html#arm-cm_qv-idle">QV_onIdle() callback</a> used in the non-preemptive configuration).</p>
<p>The THUMB-2 instruction set used exclusively in ARM Cortex-M provides a special instruction WFI (Wait-for-Interrupt) for stopping the CPU clock, as described in the "ARMv7-M Reference Manual" [ARM 06a]. The following listing shows the <code><a class="el" href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a></code> callback that puts ARM Cortex-M into a low-power mode.</p>
<p><a class="anchor" id="arm-cm_qk_onidle-code"></a><b>Listing: <a class="el" href="qvn_8h.html#a105257e3c32a7e71b06648b741c6c120" title="QV idle callback (customized in BSPs for QK)">QV_onIdle()</a> for ARM Cortex-M</b> </p><div class="fragment"><div class="line">[1] <span class="keywordtype">void</span> <a class="code" href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61">QK_onIdle</a>(<span class="keywordtype">void</span>) {</div>
<div class="line">         ~ ~ ~</div>
<div class="line">[2] #<span class="keywordflow">if</span> defined NDEBUG</div>
<div class="line">        <span class="comment">/* Put the CPU and peripherals to the low-power mode.</span></div>
<div class="line"><span class="comment">        * you might need to customize the clock management for your application,</span></div>
<div class="line"><span class="comment">        * see the datasheet for your particular Cortex-M3 MCU.</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line">[3]     __WFI(); <span class="comment">/* Wait-For-Interrupt */</span></div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The preemptive QK-nano kernel calls the <code><a class="el" href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a></code> callback with interrupts enabled. </li>
<li>
</li>
<li>
<span class="tag">2</span> The sleep mode is used only in the non-debug configuration, because sleep mode stops CPU clock, which can interfere with debugging. </li>
<li>
</li>
<li>
<span class="tag">3</span> The <code>WFI</code> instruction is generated using inline assembly. </li>
<li>
</li>
</ul>
<hr  />
 <h1><a class="anchor" id="arm-cm_qk-testing"></a>
Testing QK-nano Preemption Scenarios</h1>
<p>The <code>bsp.c</code> file included in the <span class="img folder">examples/arm-cm/dpp_ek-tm4c123gxl/qk</span> directory contains special instrumentation (an ISR designed for testing) for convenient testing of <a class="el" href="arm-cm_qk.html#arm-cm_qk-arm-cm-fig">various preemption scenarios in QK</a>.</p>
<p>The technique described in this section will allow you to trigger an interrupt at any machine instruction and observe the preemption it causes. The interrupt used for the testing purposes is the GPIOA interrupt (INTID == 0). The ISR for this interrupt is shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> GPIOPortA_IRQHandler(<span class="keywordtype">void</span>) {</div>
<div class="line">    <a class="code" href="qkn_2qfn__port_8h.html#ad3a6c9c79a8f39f1299196922e3eb6b5">QK_ISR_ENTRY</a>(); <span class="comment">/* inform QK-nano about entering an ISR */</span></div>
<div class="line">    <a class="code" href="qfn_8h.html#ac41ac57f925509fc92f9b3612f8c03b5">QACTIVE_POST</a>(AO_Table, Q_NEW(<a class="code" href="qepn_8h.html#struct_q_evt">QEvt</a>, MAX_PUB_SIG), <span class="comment">/* for testing... */</span></div>
<div class="line">                 &amp;l_GPIOPortA_IRQHandler);</div>
<div class="line">    <a class="code" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b">QK_ISR_EXIT</a>();  <span class="comment">/* inform QK-nano about exiting an ISR */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><code>GPIOPortA_IRQHandler()</code>, as all interrupts in the system, invokes the macros <a class="el" href="qkn_2qfn__port_8h.html#ad3a6c9c79a8f39f1299196922e3eb6b5" title="QK-nano ISR entry.">QK_ISR_ENTRY()</a> and <a class="el" href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="QK-nano ISR exit.">QK_ISR_EXIT()</a>, and also posts an event to the Table active object, which has higher priority than any of the Philo active object.</p>
<p>The figure below hows how to trigger the GPIOA interrupt from the CCS debugger. From the debugger you need to first open the register window and select NVIC registers from the drop-down list (see right-bottom corner of Figure 6).You scroll to the NVIC_SW_TRIG register, which denotes the Software Trigger Interrupt Register in the NVIC. This write-only register is useful for software-triggering various interrupts by writing various masks to it. To trigger the GPIOA interrupt you need to write 0x00 to the NVIC_SW_TRIG by clicking on this field, entering the value, and pressing the Enter key.</p>
<div class="image">
<img src="arm-cm_qk_test-ccs.png" alt=""/>
<div class="caption">
Triggering the GPIOA interrupt from Eclipse debugger</div></div>
<p>The general testing strategy is to break into the application at an interesting place for preemption, set breakpoints to verify which path through the code is taken, and trigger the GPIO interrupt. Next, you need to free-run the code (don’t use single stepping) so that the NVIC can perform prioritization. You observe the order in which the breakpoints are hit. This procedure will become clearer after a few examples.</p>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk-test-isr"></a>
Interrupt Nesting Test</h2>
<p>The first interesting test is verifying the correct tail-chaining to the PendSV exception after the interrupt nesting occurs, as shown in <a class="el" href="arm-cm_qk.html#arm-cm_qk-synch-fig">Synchronous Preemption in QK</a>. To test this scenario, you place a breakpoint inside the <code>GPIOPortA_IRQHandler()</code> and also inside the <code>SysTick_Handler()</code> ISR. When the breakpoint is hit, you remove the original breakpoint and place another breakpoint at the very next machine instruction (use the Disassembly window) and also another breakpoint on the first instruction of the <code>QK_PendSV</code> handler. Next you trigger the PIOINT0 interrupt per the instructions given in the previous section. You hit the Run button.</p>
<p>The pass criteria of this test are as follows:</p>
<ol type="1">
<li>The first breakpoint hit is the one inside the <code>GPIOPortA_IRQHandler()</code> function, which means that GPIO ISR preempted the SysTick ISR.</li>
<li>The second breakpoint hit is the one in the <code>SysTick_Handler()</code>, which means that the SysTick ISR continues after the PIOINT0 ISR completes.</li>
<li>The last breakpoint hit is the one in <code>PendSV_Handler()</code> exception handler, which means that the PendSV exception is tail-chained only after all interrupts are processed. You need to remove all breakpoints before proceeding to the next test.</li>
</ol>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk-test-thread"></a>
Thread Preemption Test</h2>
<p>The next interesting test is verifying that threads can preempt each other. You set a breakpoint anywhere in the Philosopher state machine code. You run the application until the breakpoint is hit. After this happens, you remove the original breakpoint and place another breakpoint at the very next machine instruction (use the Disassembly window). You also place a breakpoint inside the <code>GPIOPortA_IRQHandler()</code> interrupt handler and on the first instruction of the <code>PendSV_Handler()</code> handler. Next you trigger the GPIOA interrupt per the instructions given in the previous section. You hit the Run button.</p>
<p>The pass criteria of this test are as follows:</p>
<ol type="1">
<li>The first breakpoint hit is the one inside the <code>GPIOPortA_IRQHandler()</code> function, which means that GPIO ISR preempted the Philo thread.</li>
<li>The second breakpoint hit is the one in <code>PendSV_Handler()</code> exception handler, which means that the PendSV exception is activated before the control returns to the preempted Philosopher thread.</li>
<li>After hitting the breakpoint in <code>PendSV_Handler()</code>, you single step into <code><a class="el" href="qkn_8h.html#a57768dcdb71b3e41f329bae839584399" title="QK activator activates the next active object.">QK_activate_()</a></code>. You verify that the activator invokes a state handler from the Table state machine. This proves that the Table thread preempts the Philo thread.</li>
<li>After this you free-run the application and verify that the next breakpoint hit is the one inside the Philosopher state machine. This validates that the preempted thread continues executing only after the preempting thread (the Table state machine) completes.</li>
</ol>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk-test-fpu"></a>
Testing the FPU (Cortex-M4F)</h2>
<p>In order to test the FPU, the Board Support Package (BSP) for the Cortex-M4F EK-TM4C123GXL board uses the FPU in the following contexts:</p>
<ul>
<li>In the idle loop via the <code><a class="el" href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a></code> callback (QP priority 0)</li>
<li>In the thread level via the <code>BSP_random()</code> function called from all five Philo active objects (QP priorities 1-5).</li>
<li>In the thread level via the <code>BSP_displayPhiloStat()</code> function called from the Table active object (QP priorty 6)</li>
<li>In the ISR level via the <code>SysTick_Handler()</code> ISR (priority above all threads)</li>
</ul>
<p>To test the FPU, you could step through the code in the debugger and verify that the expected FPU-type exception stack frame is used and that the FPU registers are saved and restored by the "lazy stacking feature" when the FPU is actually used.</p>
<p>Next, you can selectively comment out the FPU code at various levels of priority and verify that the QK-nano context switching works as expected with both types of exception stak frames (with and without the FPU).</p>
<div class="separate"></div> <h2><a class="anchor" id="arm-cm_qk-test-other"></a>
Other Tests</h2>
<p>Other interesting tests that you can perform include changing priority of the GPIOA interrupt to be lower than the priority of SysTick to verify that the PendSV is still activated only after all interrupts complete.</p>
<p>In yet another test you could post an event to Philosopher active object rather than Table active object from the <code>GPIOPortA_IRQHandler()</code> function to verify that the QK-nano activator will not preempt the Philosopher thread by itself. Rather the next event will be queued and the Philosopher thread will process the queued event only after completing the current event processing. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aqkn_8h_html_a49a6ff5d3a7c6ae58e33a2b943efb2fc"><div class="ttname"><a href="qkn_8h.html#a49a6ff5d3a7c6ae58e33a2b943efb2fc">QK_sched_</a></div><div class="ttdeci">uint_fast8_t QK_sched_(void)</div><div class="ttdoc">QK-nano scheduler finds the highest-priority thread ready to run.</div><div class="ttdef"><b>Definition:</b> <a href="qkn_8c_source.html#l00247">qkn.c:247</a></div></div>
<div class="ttc" id="aqepn_8h_html_a7a86725df60bb442ac834093a779726f"><div class="ttname"><a href="qepn_8h.html#a7a86725df60bb442ac834093a779726f">Q_UINT2PTR_CAST</a></div><div class="ttdeci">#define Q_UINT2PTR_CAST(type_, uintptr_)</div><div class="ttdoc">Perform cast from unsigned integer to a pointer of type type_.</div><div class="ttdef"><b>Definition:</b> <a href="qepn_8h_source.html#l00403">qepn.h:403</a></div></div>
<div class="ttc" id="aqkn_8h_html_a57768dcdb71b3e41f329bae839584399"><div class="ttname"><a href="qkn_8h.html#a57768dcdb71b3e41f329bae839584399">QK_activate_</a></div><div class="ttdeci">void QK_activate_(void)</div><div class="ttdoc">QK activator activates the next active object.</div><div class="ttdef"><b>Definition:</b> <a href="qkn_8c_source.html#l00291">qkn.c:291</a></div></div>
<div class="ttc" id="aqkn_2qfn__port_8h_html_a18f2cc4dd2d00e3d5efb593d0754a95b"><div class="ttname"><a href="qkn_2qfn__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b">QK_ISR_EXIT</a></div><div class="ttdeci">#define QK_ISR_EXIT()</div><div class="ttdoc">QK-nano ISR exit.</div><div class="ttdef"><b>Definition:</b> <a href="qkn_2qfn__port_8h_source.html#l00130">qkn/qfn_port.h:130</a></div></div>
<div class="ttc" id="astdint_8h_html_ad0906fbe05a45fbdb000c58fe8929e70"><div class="ttname"><a href="stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a></div><div class="ttdeci">unsigned int uint_fast8_t</div><div class="ttdoc">fast at-least 8-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="stdint_8h_source.html#l00037">stdint.h:37</a></div></div>
<div class="ttc" id="aqkn_2qfn__port_8h_html_ad3a6c9c79a8f39f1299196922e3eb6b5"><div class="ttname"><a href="qkn_2qfn__port_8h.html#ad3a6c9c79a8f39f1299196922e3eb6b5">QK_ISR_ENTRY</a></div><div class="ttdeci">#define QK_ISR_ENTRY()</div><div class="ttdoc">QK-nano ISR entry.</div><div class="ttdef"><b>Definition:</b> <a href="qkn_2qfn__port_8h_source.html#l00127">qkn/qfn_port.h:127</a></div></div>
<div class="ttc" id="aqkn_8h_html_a667daad24b172e782fe4e2b5b06fbf61"><div class="ttname"><a href="qkn_8h.html#a667daad24b172e782fe4e2b5b06fbf61">QK_onIdle</a></div><div class="ttdeci">void QK_onIdle(void)</div><div class="ttdoc">QK idle callback (customized in BSPs for QK)</div></div>
<div class="ttc" id="aqfn_8h_html_ac41ac57f925509fc92f9b3612f8c03b5"><div class="ttname"><a href="qfn_8h.html#ac41ac57f925509fc92f9b3612f8c03b5">QACTIVE_POST</a></div><div class="ttdeci">#define QACTIVE_POST(me_, sig_, par_)</div><div class="ttdoc">Polymorphically posts an event to an active object (FIFO) with delivery guarantee (task context).</div><div class="ttdef"><b>Definition:</b> <a href="qfn_8h_source.html#l00197">qfn.h:197</a></div></div>
<div class="ttc" id="aqkn_2qfn__port_8h_html_ae1fa4705c311e29699a0164a20362bf1"><div class="ttname"><a href="qkn_2qfn__port_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a></div><div class="ttdeci">void QK_init(void)</div></div>
<div class="ttc" id="aqepn_8h_html_struct_q_evt"><div class="ttname"><a href="qepn_8h.html#struct_q_evt">QEvt</a></div><div class="ttdoc">Event structure.</div><div class="ttdef"><b>Definition:</b> <a href="qepn_8h_source.html#l00131">qepn.h:131</a></div></div>
<div class="ttc" id="aqkn_2qfn__port_8h_html_a1e726be02d56193ed854282969834806"><div class="ttname"><a href="qkn_2qfn__port_8h.html#a1e726be02d56193ed854282969834806">QK_INIT</a></div><div class="ttdeci">#define QK_INIT()</div><div class="ttdoc">Macro that specifies QK-nano initialization.</div><div class="ttdef"><b>Definition:</b> <a href="qkn_2qfn__port_8h_source.html#l00144">qkn/qfn_port.h:144</a></div></div>
<div class="ttc" id="aqkn_2qfn__port_8h_html_a88df5203e3a9716327b58923f5aaac80"><div class="ttname"><a href="qkn_2qfn__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a></div><div class="ttdeci">#define QF_INT_DISABLE()</div><div class="ttdoc">The macro defines the mechanism of locking the interrupts.</div><div class="ttdef"><b>Definition:</b> <a href="qkn_2qfn__port_8h_source.html#l00110">qkn/qfn_port.h:110</a></div></div>
<div class="ttc" id="astdint_8h_html_a06896e8c53f721507066c079052171f8"><div class="ttname"><a href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a></div><div class="ttdeci">unsigned long uint32_t</div><div class="ttdoc">exact-width 32-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="stdint_8h_source.html#l00032">stdint.h:32</a></div></div>
<div class="ttc" id="aqkn_2qfn__port_8h_html_ad2d11956704ad838c9c954368d3d37d5"><div class="ttname"><a href="qkn_2qfn__port_8h.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a></div><div class="ttdeci">#define QF_INT_ENABLE()</div><div class="ttdoc">The macro defines the mechanism of unlocking the interrupts.</div><div class="ttdef"><b>Definition:</b> <a href="qkn_2qfn__port_8h_source.html#l00121">qkn/qfn_port.h:121</a></div></div>
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP-nano 6.8.0</b>
    </li>
  </ul>
</div>
</body>
</html>
